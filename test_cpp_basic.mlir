module {
  llvm.func @malloc(i64) -> !llvm.ptr
  func.func @linear_layer_f32(%arg0: tensor<32x128xf32>, %arg1: tensor<128x64xf32>, %arg2: tensor<64xf32>) -> tensor<32x64xf32> {
    %0 = llvm.mlir.constant(128 : index) : i64
    %1 = builtin.unrealized_conversion_cast %0 : i64 to index
    %2 = llvm.mlir.constant(64 : index) : i64
    %3 = builtin.unrealized_conversion_cast %2 : i64 to index
    %4 = llvm.mlir.constant(1 : index) : i64
    %5 = builtin.unrealized_conversion_cast %4 : i64 to index
    %6 = llvm.mlir.constant(32 : index) : i64
    %7 = builtin.unrealized_conversion_cast %6 : i64 to index
    %8 = llvm.mlir.constant(0 : index) : i64
    %9 = builtin.unrealized_conversion_cast %8 : i64 to index
    %10 = llvm.mlir.constant(0.000000e+00 : f32) : f32
    %11 = bufferization.to_buffer %arg2 : tensor<64xf32> to memref<64xf32, strided<[?], offset: ?>>
    %12 = builtin.unrealized_conversion_cast %11 : memref<64xf32, strided<[?], offset: ?>> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %13 = bufferization.to_buffer %arg1 : tensor<128x64xf32> to memref<128x64xf32, strided<[?, ?], offset: ?>>
    %14 = builtin.unrealized_conversion_cast %13 : memref<128x64xf32, strided<[?, ?], offset: ?>> to !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)>
    %15 = bufferization.to_buffer %arg0 : tensor<32x128xf32> to memref<32x128xf32, strided<[?, ?], offset: ?>>
    %16 = builtin.unrealized_conversion_cast %15 : memref<32x128xf32, strided<[?, ?], offset: ?>> to !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)>
    %17 = llvm.mlir.constant(32 : index) : i64
    %18 = llvm.mlir.constant(64 : index) : i64
    %19 = llvm.mlir.constant(1 : index) : i64
    %20 = llvm.mlir.constant(2048 : index) : i64
    %21 = llvm.mlir.zero : !llvm.ptr
    %22 = llvm.getelementptr %21[%20] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %23 = llvm.ptrtoint %22 : !llvm.ptr to i64
    %24 = llvm.mlir.constant(64 : index) : i64
    %25 = llvm.add %23, %24 : i64
    %26 = llvm.call @malloc(%25) : (i64) -> !llvm.ptr
    %27 = llvm.ptrtoint %26 : !llvm.ptr to i64
    %28 = llvm.mlir.constant(1 : index) : i64
    %29 = llvm.sub %24, %28 : i64
    %30 = llvm.add %27, %29 : i64
    %31 = llvm.urem %30, %24 : i64
    %32 = llvm.sub %30, %31 : i64
    %33 = llvm.inttoptr %32 : i64 to !llvm.ptr
    %34 = llvm.mlir.poison : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)>
    %35 = llvm.insertvalue %26, %34[0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %36 = llvm.insertvalue %33, %35[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %37 = llvm.mlir.constant(0 : index) : i64
    %38 = llvm.insertvalue %37, %36[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %39 = llvm.insertvalue %17, %38[3, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %40 = llvm.insertvalue %18, %39[3, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %41 = llvm.insertvalue %18, %40[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %42 = llvm.insertvalue %19, %41[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    scf.for %arg3 = %9 to %7 step %5 {
      %97 = builtin.unrealized_conversion_cast %arg3 : index to i64
      scf.for %arg4 = %9 to %3 step %5 {
        %98 = builtin.unrealized_conversion_cast %arg4 : index to i64
        scf.for %arg5 = %9 to %1 step %5 {
          %99 = builtin.unrealized_conversion_cast %arg5 : index to i64
          %100 = llvm.extractvalue %16[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %101 = llvm.extractvalue %16[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %102 = llvm.getelementptr %100[%101] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %103 = llvm.extractvalue %16[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %104 = llvm.mul %97, %103 overflow<nsw, nuw> : i64
          %105 = llvm.extractvalue %16[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %106 = llvm.mul %99, %105 overflow<nsw, nuw> : i64
          %107 = llvm.add %104, %106 overflow<nsw, nuw> : i64
          %108 = llvm.getelementptr inbounds|nuw %102[%107] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %109 = llvm.load %108 : !llvm.ptr -> f32
          %110 = llvm.extractvalue %14[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %111 = llvm.extractvalue %14[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %112 = llvm.getelementptr %110[%111] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %113 = llvm.extractvalue %14[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %114 = llvm.mul %99, %113 overflow<nsw, nuw> : i64
          %115 = llvm.extractvalue %14[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %116 = llvm.mul %98, %115 overflow<nsw, nuw> : i64
          %117 = llvm.add %114, %116 overflow<nsw, nuw> : i64
          %118 = llvm.getelementptr inbounds|nuw %112[%117] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %119 = llvm.load %118 : !llvm.ptr -> f32
          %120 = llvm.extractvalue %42[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %121 = llvm.mlir.constant(64 : index) : i64
          %122 = llvm.mul %97, %121 overflow<nsw, nuw> : i64
          %123 = llvm.add %122, %98 overflow<nsw, nuw> : i64
          %124 = llvm.getelementptr inbounds|nuw %120[%123] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %125 = llvm.load %124 : !llvm.ptr -> f32
          %126 = llvm.fmul %109, %119 : f32
          %127 = llvm.fadd %125, %126 : f32
          %128 = llvm.extractvalue %42[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %129 = llvm.mlir.constant(64 : index) : i64
          %130 = llvm.mul %97, %129 overflow<nsw, nuw> : i64
          %131 = llvm.add %130, %98 overflow<nsw, nuw> : i64
          %132 = llvm.getelementptr inbounds|nuw %128[%131] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.store %127, %132 : f32, !llvm.ptr
        }
      }
    }
    %43 = llvm.mlir.constant(32 : index) : i64
    %44 = llvm.mlir.constant(64 : index) : i64
    %45 = llvm.mlir.constant(1 : index) : i64
    %46 = llvm.mlir.constant(2048 : index) : i64
    %47 = llvm.mlir.zero : !llvm.ptr
    %48 = llvm.getelementptr %47[%46] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %49 = llvm.ptrtoint %48 : !llvm.ptr to i64
    %50 = llvm.mlir.constant(64 : index) : i64
    %51 = llvm.add %49, %50 : i64
    %52 = llvm.call @malloc(%51) : (i64) -> !llvm.ptr
    %53 = llvm.ptrtoint %52 : !llvm.ptr to i64
    %54 = llvm.mlir.constant(1 : index) : i64
    %55 = llvm.sub %50, %54 : i64
    %56 = llvm.add %53, %55 : i64
    %57 = llvm.urem %56, %50 : i64
    %58 = llvm.sub %56, %57 : i64
    %59 = llvm.inttoptr %58 : i64 to !llvm.ptr
    %60 = llvm.mlir.poison : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)>
    %61 = llvm.insertvalue %52, %60[0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %62 = llvm.insertvalue %59, %61[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %63 = llvm.mlir.constant(0 : index) : i64
    %64 = llvm.insertvalue %63, %62[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %65 = llvm.insertvalue %43, %64[3, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %66 = llvm.insertvalue %44, %65[3, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %67 = llvm.insertvalue %44, %66[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %68 = llvm.insertvalue %45, %67[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    scf.for %arg3 = %9 to %7 step %5 {
      %97 = builtin.unrealized_conversion_cast %arg3 : index to i64
      scf.for %arg4 = %9 to %3 step %5 {
        %98 = builtin.unrealized_conversion_cast %arg4 : index to i64
        %99 = llvm.extractvalue %12[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %100 = llvm.extractvalue %12[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %101 = llvm.getelementptr %99[%100] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %102 = llvm.extractvalue %12[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %103 = llvm.mul %98, %102 overflow<nsw, nuw> : i64
        %104 = llvm.getelementptr inbounds|nuw %101[%103] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %105 = llvm.load %104 : !llvm.ptr -> f32
        %106 = llvm.extractvalue %68[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
        %107 = llvm.mlir.constant(64 : index) : i64
        %108 = llvm.mul %97, %107 overflow<nsw, nuw> : i64
        %109 = llvm.add %108, %98 overflow<nsw, nuw> : i64
        %110 = llvm.getelementptr inbounds|nuw %106[%109] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        llvm.store %105, %110 : f32, !llvm.ptr
      }
    }
    %69 = llvm.mlir.constant(32 : index) : i64
    %70 = llvm.mlir.constant(64 : index) : i64
    %71 = llvm.mlir.constant(1 : index) : i64
    %72 = llvm.mlir.constant(2048 : index) : i64
    %73 = llvm.mlir.zero : !llvm.ptr
    %74 = llvm.getelementptr %73[%72] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %75 = llvm.ptrtoint %74 : !llvm.ptr to i64
    %76 = llvm.mlir.constant(64 : index) : i64
    %77 = llvm.add %75, %76 : i64
    %78 = llvm.call @malloc(%77) : (i64) -> !llvm.ptr
    %79 = llvm.ptrtoint %78 : !llvm.ptr to i64
    %80 = llvm.mlir.constant(1 : index) : i64
    %81 = llvm.sub %76, %80 : i64
    %82 = llvm.add %79, %81 : i64
    %83 = llvm.urem %82, %76 : i64
    %84 = llvm.sub %82, %83 : i64
    %85 = llvm.inttoptr %84 : i64 to !llvm.ptr
    %86 = llvm.mlir.poison : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)>
    %87 = llvm.insertvalue %78, %86[0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %88 = llvm.insertvalue %85, %87[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %89 = llvm.mlir.constant(0 : index) : i64
    %90 = llvm.insertvalue %89, %88[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %91 = llvm.insertvalue %69, %90[3, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %92 = llvm.insertvalue %70, %91[3, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %93 = llvm.insertvalue %70, %92[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %94 = llvm.insertvalue %71, %93[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %95 = builtin.unrealized_conversion_cast %94 : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> to memref<32x64xf32>
    scf.for %arg3 = %9 to %7 step %5 {
      %97 = builtin.unrealized_conversion_cast %arg3 : index to i64
      scf.for %arg4 = %9 to %3 step %5 {
        %98 = builtin.unrealized_conversion_cast %arg4 : index to i64
        %99 = llvm.extractvalue %42[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
        %100 = llvm.mlir.constant(64 : index) : i64
        %101 = llvm.mul %97, %100 overflow<nsw, nuw> : i64
        %102 = llvm.add %101, %98 overflow<nsw, nuw> : i64
        %103 = llvm.getelementptr inbounds|nuw %99[%102] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %104 = llvm.load %103 : !llvm.ptr -> f32
        %105 = llvm.extractvalue %68[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
        %106 = llvm.mlir.constant(64 : index) : i64
        %107 = llvm.mul %97, %106 overflow<nsw, nuw> : i64
        %108 = llvm.add %107, %98 overflow<nsw, nuw> : i64
        %109 = llvm.getelementptr inbounds|nuw %105[%108] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %110 = llvm.load %109 : !llvm.ptr -> f32
        %111 = llvm.fadd %104, %110 : f32
        %112 = llvm.intr.maximum(%111, %10) : (f32, f32) -> f32
        %113 = llvm.extractvalue %94[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
        %114 = llvm.mlir.constant(64 : index) : i64
        %115 = llvm.mul %97, %114 overflow<nsw, nuw> : i64
        %116 = llvm.add %115, %98 overflow<nsw, nuw> : i64
        %117 = llvm.getelementptr inbounds|nuw %113[%116] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        llvm.store %112, %117 : f32, !llvm.ptr
      }
    }
    %96 = bufferization.to_tensor %95 : memref<32x64xf32> to tensor<32x64xf32>
    return %96 : tensor<32x64xf32>
  }
  func.func @large_linear_layer_f32(%arg0: tensor<256x512xf32>, %arg1: tensor<512x256xf32>, %arg2: tensor<256xf32>) -> tensor<256x256xf32> {
    %0 = llvm.mlir.constant(512 : index) : i64
    %1 = builtin.unrealized_conversion_cast %0 : i64 to index
    %2 = llvm.mlir.constant(1 : index) : i64
    %3 = builtin.unrealized_conversion_cast %2 : i64 to index
    %4 = llvm.mlir.constant(256 : index) : i64
    %5 = builtin.unrealized_conversion_cast %4 : i64 to index
    %6 = llvm.mlir.constant(0 : index) : i64
    %7 = builtin.unrealized_conversion_cast %6 : i64 to index
    %8 = llvm.mlir.constant(0.000000e+00 : f32) : f32
    %9 = bufferization.to_buffer %arg2 : tensor<256xf32> to memref<256xf32, strided<[?], offset: ?>>
    %10 = builtin.unrealized_conversion_cast %9 : memref<256xf32, strided<[?], offset: ?>> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %11 = bufferization.to_buffer %arg1 : tensor<512x256xf32> to memref<512x256xf32, strided<[?, ?], offset: ?>>
    %12 = builtin.unrealized_conversion_cast %11 : memref<512x256xf32, strided<[?, ?], offset: ?>> to !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)>
    %13 = bufferization.to_buffer %arg0 : tensor<256x512xf32> to memref<256x512xf32, strided<[?, ?], offset: ?>>
    %14 = builtin.unrealized_conversion_cast %13 : memref<256x512xf32, strided<[?, ?], offset: ?>> to !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)>
    %15 = llvm.mlir.constant(256 : index) : i64
    %16 = llvm.mlir.constant(256 : index) : i64
    %17 = llvm.mlir.constant(1 : index) : i64
    %18 = llvm.mlir.constant(65536 : index) : i64
    %19 = llvm.mlir.zero : !llvm.ptr
    %20 = llvm.getelementptr %19[%18] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %21 = llvm.ptrtoint %20 : !llvm.ptr to i64
    %22 = llvm.mlir.constant(64 : index) : i64
    %23 = llvm.add %21, %22 : i64
    %24 = llvm.call @malloc(%23) : (i64) -> !llvm.ptr
    %25 = llvm.ptrtoint %24 : !llvm.ptr to i64
    %26 = llvm.mlir.constant(1 : index) : i64
    %27 = llvm.sub %22, %26 : i64
    %28 = llvm.add %25, %27 : i64
    %29 = llvm.urem %28, %22 : i64
    %30 = llvm.sub %28, %29 : i64
    %31 = llvm.inttoptr %30 : i64 to !llvm.ptr
    %32 = llvm.mlir.poison : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)>
    %33 = llvm.insertvalue %24, %32[0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %34 = llvm.insertvalue %31, %33[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %35 = llvm.mlir.constant(0 : index) : i64
    %36 = llvm.insertvalue %35, %34[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %37 = llvm.insertvalue %15, %36[3, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %38 = llvm.insertvalue %16, %37[3, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %39 = llvm.insertvalue %16, %38[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %40 = llvm.insertvalue %17, %39[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    scf.for %arg3 = %7 to %5 step %3 {
      %95 = builtin.unrealized_conversion_cast %arg3 : index to i64
      scf.for %arg4 = %7 to %5 step %3 {
        %96 = builtin.unrealized_conversion_cast %arg4 : index to i64
        scf.for %arg5 = %7 to %1 step %3 {
          %97 = builtin.unrealized_conversion_cast %arg5 : index to i64
          %98 = llvm.extractvalue %14[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %99 = llvm.extractvalue %14[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %100 = llvm.getelementptr %98[%99] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %101 = llvm.extractvalue %14[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %102 = llvm.mul %95, %101 overflow<nsw, nuw> : i64
          %103 = llvm.extractvalue %14[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %104 = llvm.mul %97, %103 overflow<nsw, nuw> : i64
          %105 = llvm.add %102, %104 overflow<nsw, nuw> : i64
          %106 = llvm.getelementptr inbounds|nuw %100[%105] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %107 = llvm.load %106 : !llvm.ptr -> f32
          %108 = llvm.extractvalue %12[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %109 = llvm.extractvalue %12[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %110 = llvm.getelementptr %108[%109] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %111 = llvm.extractvalue %12[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %112 = llvm.mul %97, %111 overflow<nsw, nuw> : i64
          %113 = llvm.extractvalue %12[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %114 = llvm.mul %96, %113 overflow<nsw, nuw> : i64
          %115 = llvm.add %112, %114 overflow<nsw, nuw> : i64
          %116 = llvm.getelementptr inbounds|nuw %110[%115] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %117 = llvm.load %116 : !llvm.ptr -> f32
          %118 = llvm.extractvalue %40[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %119 = llvm.mlir.constant(256 : index) : i64
          %120 = llvm.mul %95, %119 overflow<nsw, nuw> : i64
          %121 = llvm.add %120, %96 overflow<nsw, nuw> : i64
          %122 = llvm.getelementptr inbounds|nuw %118[%121] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %123 = llvm.load %122 : !llvm.ptr -> f32
          %124 = llvm.fmul %107, %117 : f32
          %125 = llvm.fadd %123, %124 : f32
          %126 = llvm.extractvalue %40[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %127 = llvm.mlir.constant(256 : index) : i64
          %128 = llvm.mul %95, %127 overflow<nsw, nuw> : i64
          %129 = llvm.add %128, %96 overflow<nsw, nuw> : i64
          %130 = llvm.getelementptr inbounds|nuw %126[%129] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.store %125, %130 : f32, !llvm.ptr
        }
      }
    }
    %41 = llvm.mlir.constant(256 : index) : i64
    %42 = llvm.mlir.constant(256 : index) : i64
    %43 = llvm.mlir.constant(1 : index) : i64
    %44 = llvm.mlir.constant(65536 : index) : i64
    %45 = llvm.mlir.zero : !llvm.ptr
    %46 = llvm.getelementptr %45[%44] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %47 = llvm.ptrtoint %46 : !llvm.ptr to i64
    %48 = llvm.mlir.constant(64 : index) : i64
    %49 = llvm.add %47, %48 : i64
    %50 = llvm.call @malloc(%49) : (i64) -> !llvm.ptr
    %51 = llvm.ptrtoint %50 : !llvm.ptr to i64
    %52 = llvm.mlir.constant(1 : index) : i64
    %53 = llvm.sub %48, %52 : i64
    %54 = llvm.add %51, %53 : i64
    %55 = llvm.urem %54, %48 : i64
    %56 = llvm.sub %54, %55 : i64
    %57 = llvm.inttoptr %56 : i64 to !llvm.ptr
    %58 = llvm.mlir.poison : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)>
    %59 = llvm.insertvalue %50, %58[0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %60 = llvm.insertvalue %57, %59[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %61 = llvm.mlir.constant(0 : index) : i64
    %62 = llvm.insertvalue %61, %60[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %63 = llvm.insertvalue %41, %62[3, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %64 = llvm.insertvalue %42, %63[3, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %65 = llvm.insertvalue %42, %64[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %66 = llvm.insertvalue %43, %65[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    scf.for %arg3 = %7 to %5 step %3 {
      %95 = builtin.unrealized_conversion_cast %arg3 : index to i64
      scf.for %arg4 = %7 to %5 step %3 {
        %96 = builtin.unrealized_conversion_cast %arg4 : index to i64
        %97 = llvm.extractvalue %10[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %98 = llvm.extractvalue %10[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %99 = llvm.getelementptr %97[%98] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %100 = llvm.extractvalue %10[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %101 = llvm.mul %96, %100 overflow<nsw, nuw> : i64
        %102 = llvm.getelementptr inbounds|nuw %99[%101] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %103 = llvm.load %102 : !llvm.ptr -> f32
        %104 = llvm.extractvalue %66[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
        %105 = llvm.mlir.constant(256 : index) : i64
        %106 = llvm.mul %95, %105 overflow<nsw, nuw> : i64
        %107 = llvm.add %106, %96 overflow<nsw, nuw> : i64
        %108 = llvm.getelementptr inbounds|nuw %104[%107] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        llvm.store %103, %108 : f32, !llvm.ptr
      }
    }
    %67 = llvm.mlir.constant(256 : index) : i64
    %68 = llvm.mlir.constant(256 : index) : i64
    %69 = llvm.mlir.constant(1 : index) : i64
    %70 = llvm.mlir.constant(65536 : index) : i64
    %71 = llvm.mlir.zero : !llvm.ptr
    %72 = llvm.getelementptr %71[%70] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %73 = llvm.ptrtoint %72 : !llvm.ptr to i64
    %74 = llvm.mlir.constant(64 : index) : i64
    %75 = llvm.add %73, %74 : i64
    %76 = llvm.call @malloc(%75) : (i64) -> !llvm.ptr
    %77 = llvm.ptrtoint %76 : !llvm.ptr to i64
    %78 = llvm.mlir.constant(1 : index) : i64
    %79 = llvm.sub %74, %78 : i64
    %80 = llvm.add %77, %79 : i64
    %81 = llvm.urem %80, %74 : i64
    %82 = llvm.sub %80, %81 : i64
    %83 = llvm.inttoptr %82 : i64 to !llvm.ptr
    %84 = llvm.mlir.poison : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)>
    %85 = llvm.insertvalue %76, %84[0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %86 = llvm.insertvalue %83, %85[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %87 = llvm.mlir.constant(0 : index) : i64
    %88 = llvm.insertvalue %87, %86[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %89 = llvm.insertvalue %67, %88[3, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %90 = llvm.insertvalue %68, %89[3, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %91 = llvm.insertvalue %68, %90[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %92 = llvm.insertvalue %69, %91[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %93 = builtin.unrealized_conversion_cast %92 : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> to memref<256x256xf32>
    scf.for %arg3 = %7 to %5 step %3 {
      %95 = builtin.unrealized_conversion_cast %arg3 : index to i64
      scf.for %arg4 = %7 to %5 step %3 {
        %96 = builtin.unrealized_conversion_cast %arg4 : index to i64
        %97 = llvm.extractvalue %40[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
        %98 = llvm.mlir.constant(256 : index) : i64
        %99 = llvm.mul %95, %98 overflow<nsw, nuw> : i64
        %100 = llvm.add %99, %96 overflow<nsw, nuw> : i64
        %101 = llvm.getelementptr inbounds|nuw %97[%100] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %102 = llvm.load %101 : !llvm.ptr -> f32
        %103 = llvm.extractvalue %66[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
        %104 = llvm.mlir.constant(256 : index) : i64
        %105 = llvm.mul %95, %104 overflow<nsw, nuw> : i64
        %106 = llvm.add %105, %96 overflow<nsw, nuw> : i64
        %107 = llvm.getelementptr inbounds|nuw %103[%106] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %108 = llvm.load %107 : !llvm.ptr -> f32
        %109 = llvm.fadd %102, %108 : f32
        %110 = llvm.intr.maximum(%109, %8) : (f32, f32) -> f32
        %111 = llvm.extractvalue %92[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
        %112 = llvm.mlir.constant(256 : index) : i64
        %113 = llvm.mul %95, %112 overflow<nsw, nuw> : i64
        %114 = llvm.add %113, %96 overflow<nsw, nuw> : i64
        %115 = llvm.getelementptr inbounds|nuw %111[%114] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        llvm.store %110, %115 : f32, !llvm.ptr
      }
    }
    %94 = bufferization.to_tensor %93 : memref<256x256xf32> to tensor<256x256xf32>
    return %94 : tensor<256x256xf32>
  }
  func.func @small_batch_linear_f32(%arg0: tensor<1x784xf32>, %arg1: tensor<784x128xf32>, %arg2: tensor<128xf32>) -> tensor<1x128xf32> {
    %0 = llvm.mlir.constant(784 : index) : i64
    %1 = builtin.unrealized_conversion_cast %0 : i64 to index
    %2 = llvm.mlir.constant(128 : index) : i64
    %3 = builtin.unrealized_conversion_cast %2 : i64 to index
    %4 = llvm.mlir.constant(1 : index) : i64
    %5 = builtin.unrealized_conversion_cast %4 : i64 to index
    %6 = llvm.mlir.constant(0 : index) : i64
    %7 = builtin.unrealized_conversion_cast %6 : i64 to index
    %8 = llvm.mlir.constant(0.000000e+00 : f32) : f32
    %9 = bufferization.to_buffer %arg2 : tensor<128xf32> to memref<128xf32, strided<[?], offset: ?>>
    %10 = builtin.unrealized_conversion_cast %9 : memref<128xf32, strided<[?], offset: ?>> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %11 = bufferization.to_buffer %arg1 : tensor<784x128xf32> to memref<784x128xf32, strided<[?, ?], offset: ?>>
    %12 = builtin.unrealized_conversion_cast %11 : memref<784x128xf32, strided<[?, ?], offset: ?>> to !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)>
    %13 = bufferization.to_buffer %arg0 : tensor<1x784xf32> to memref<1x784xf32, strided<[?, ?], offset: ?>>
    %14 = builtin.unrealized_conversion_cast %13 : memref<1x784xf32, strided<[?, ?], offset: ?>> to !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)>
    %15 = llvm.mlir.constant(1 : index) : i64
    %16 = llvm.mlir.constant(128 : index) : i64
    %17 = llvm.mlir.constant(1 : index) : i64
    %18 = llvm.mlir.constant(128 : index) : i64
    %19 = llvm.mlir.zero : !llvm.ptr
    %20 = llvm.getelementptr %19[%18] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %21 = llvm.ptrtoint %20 : !llvm.ptr to i64
    %22 = llvm.mlir.constant(64 : index) : i64
    %23 = llvm.add %21, %22 : i64
    %24 = llvm.call @malloc(%23) : (i64) -> !llvm.ptr
    %25 = llvm.ptrtoint %24 : !llvm.ptr to i64
    %26 = llvm.mlir.constant(1 : index) : i64
    %27 = llvm.sub %22, %26 : i64
    %28 = llvm.add %25, %27 : i64
    %29 = llvm.urem %28, %22 : i64
    %30 = llvm.sub %28, %29 : i64
    %31 = llvm.inttoptr %30 : i64 to !llvm.ptr
    %32 = llvm.mlir.poison : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)>
    %33 = llvm.insertvalue %24, %32[0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %34 = llvm.insertvalue %31, %33[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %35 = llvm.mlir.constant(0 : index) : i64
    %36 = llvm.insertvalue %35, %34[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %37 = llvm.insertvalue %15, %36[3, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %38 = llvm.insertvalue %16, %37[3, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %39 = llvm.insertvalue %16, %38[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %40 = llvm.insertvalue %17, %39[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    scf.for %arg3 = %7 to %5 step %5 {
      %95 = builtin.unrealized_conversion_cast %arg3 : index to i64
      scf.for %arg4 = %7 to %3 step %5 {
        %96 = builtin.unrealized_conversion_cast %arg4 : index to i64
        scf.for %arg5 = %7 to %1 step %5 {
          %97 = builtin.unrealized_conversion_cast %arg5 : index to i64
          %98 = llvm.extractvalue %14[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %99 = llvm.extractvalue %14[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %100 = llvm.getelementptr %98[%99] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %101 = llvm.extractvalue %14[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %102 = llvm.mul %95, %101 overflow<nsw, nuw> : i64
          %103 = llvm.extractvalue %14[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %104 = llvm.mul %97, %103 overflow<nsw, nuw> : i64
          %105 = llvm.add %102, %104 overflow<nsw, nuw> : i64
          %106 = llvm.getelementptr inbounds|nuw %100[%105] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %107 = llvm.load %106 : !llvm.ptr -> f32
          %108 = llvm.extractvalue %12[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %109 = llvm.extractvalue %12[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %110 = llvm.getelementptr %108[%109] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %111 = llvm.extractvalue %12[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %112 = llvm.mul %97, %111 overflow<nsw, nuw> : i64
          %113 = llvm.extractvalue %12[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %114 = llvm.mul %96, %113 overflow<nsw, nuw> : i64
          %115 = llvm.add %112, %114 overflow<nsw, nuw> : i64
          %116 = llvm.getelementptr inbounds|nuw %110[%115] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %117 = llvm.load %116 : !llvm.ptr -> f32
          %118 = llvm.extractvalue %40[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %119 = llvm.mlir.constant(128 : index) : i64
          %120 = llvm.mul %95, %119 overflow<nsw, nuw> : i64
          %121 = llvm.add %120, %96 overflow<nsw, nuw> : i64
          %122 = llvm.getelementptr inbounds|nuw %118[%121] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %123 = llvm.load %122 : !llvm.ptr -> f32
          %124 = llvm.fmul %107, %117 : f32
          %125 = llvm.fadd %123, %124 : f32
          %126 = llvm.extractvalue %40[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %127 = llvm.mlir.constant(128 : index) : i64
          %128 = llvm.mul %95, %127 overflow<nsw, nuw> : i64
          %129 = llvm.add %128, %96 overflow<nsw, nuw> : i64
          %130 = llvm.getelementptr inbounds|nuw %126[%129] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.store %125, %130 : f32, !llvm.ptr
        }
      }
    }
    %41 = llvm.mlir.constant(1 : index) : i64
    %42 = llvm.mlir.constant(128 : index) : i64
    %43 = llvm.mlir.constant(1 : index) : i64
    %44 = llvm.mlir.constant(128 : index) : i64
    %45 = llvm.mlir.zero : !llvm.ptr
    %46 = llvm.getelementptr %45[%44] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %47 = llvm.ptrtoint %46 : !llvm.ptr to i64
    %48 = llvm.mlir.constant(64 : index) : i64
    %49 = llvm.add %47, %48 : i64
    %50 = llvm.call @malloc(%49) : (i64) -> !llvm.ptr
    %51 = llvm.ptrtoint %50 : !llvm.ptr to i64
    %52 = llvm.mlir.constant(1 : index) : i64
    %53 = llvm.sub %48, %52 : i64
    %54 = llvm.add %51, %53 : i64
    %55 = llvm.urem %54, %48 : i64
    %56 = llvm.sub %54, %55 : i64
    %57 = llvm.inttoptr %56 : i64 to !llvm.ptr
    %58 = llvm.mlir.poison : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)>
    %59 = llvm.insertvalue %50, %58[0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %60 = llvm.insertvalue %57, %59[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %61 = llvm.mlir.constant(0 : index) : i64
    %62 = llvm.insertvalue %61, %60[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %63 = llvm.insertvalue %41, %62[3, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %64 = llvm.insertvalue %42, %63[3, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %65 = llvm.insertvalue %42, %64[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %66 = llvm.insertvalue %43, %65[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    scf.for %arg3 = %7 to %5 step %5 {
      %95 = builtin.unrealized_conversion_cast %arg3 : index to i64
      scf.for %arg4 = %7 to %3 step %5 {
        %96 = builtin.unrealized_conversion_cast %arg4 : index to i64
        %97 = llvm.extractvalue %10[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %98 = llvm.extractvalue %10[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %99 = llvm.getelementptr %97[%98] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %100 = llvm.extractvalue %10[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %101 = llvm.mul %96, %100 overflow<nsw, nuw> : i64
        %102 = llvm.getelementptr inbounds|nuw %99[%101] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %103 = llvm.load %102 : !llvm.ptr -> f32
        %104 = llvm.extractvalue %66[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
        %105 = llvm.mlir.constant(128 : index) : i64
        %106 = llvm.mul %95, %105 overflow<nsw, nuw> : i64
        %107 = llvm.add %106, %96 overflow<nsw, nuw> : i64
        %108 = llvm.getelementptr inbounds|nuw %104[%107] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        llvm.store %103, %108 : f32, !llvm.ptr
      }
    }
    %67 = llvm.mlir.constant(1 : index) : i64
    %68 = llvm.mlir.constant(128 : index) : i64
    %69 = llvm.mlir.constant(1 : index) : i64
    %70 = llvm.mlir.constant(128 : index) : i64
    %71 = llvm.mlir.zero : !llvm.ptr
    %72 = llvm.getelementptr %71[%70] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %73 = llvm.ptrtoint %72 : !llvm.ptr to i64
    %74 = llvm.mlir.constant(64 : index) : i64
    %75 = llvm.add %73, %74 : i64
    %76 = llvm.call @malloc(%75) : (i64) -> !llvm.ptr
    %77 = llvm.ptrtoint %76 : !llvm.ptr to i64
    %78 = llvm.mlir.constant(1 : index) : i64
    %79 = llvm.sub %74, %78 : i64
    %80 = llvm.add %77, %79 : i64
    %81 = llvm.urem %80, %74 : i64
    %82 = llvm.sub %80, %81 : i64
    %83 = llvm.inttoptr %82 : i64 to !llvm.ptr
    %84 = llvm.mlir.poison : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)>
    %85 = llvm.insertvalue %76, %84[0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %86 = llvm.insertvalue %83, %85[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %87 = llvm.mlir.constant(0 : index) : i64
    %88 = llvm.insertvalue %87, %86[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %89 = llvm.insertvalue %67, %88[3, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %90 = llvm.insertvalue %68, %89[3, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %91 = llvm.insertvalue %68, %90[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %92 = llvm.insertvalue %69, %91[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %93 = builtin.unrealized_conversion_cast %92 : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> to memref<1x128xf32>
    scf.for %arg3 = %7 to %5 step %5 {
      %95 = builtin.unrealized_conversion_cast %arg3 : index to i64
      scf.for %arg4 = %7 to %3 step %5 {
        %96 = builtin.unrealized_conversion_cast %arg4 : index to i64
        %97 = llvm.extractvalue %40[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
        %98 = llvm.mlir.constant(128 : index) : i64
        %99 = llvm.mul %95, %98 overflow<nsw, nuw> : i64
        %100 = llvm.add %99, %96 overflow<nsw, nuw> : i64
        %101 = llvm.getelementptr inbounds|nuw %97[%100] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %102 = llvm.load %101 : !llvm.ptr -> f32
        %103 = llvm.extractvalue %66[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
        %104 = llvm.mlir.constant(128 : index) : i64
        %105 = llvm.mul %95, %104 overflow<nsw, nuw> : i64
        %106 = llvm.add %105, %96 overflow<nsw, nuw> : i64
        %107 = llvm.getelementptr inbounds|nuw %103[%106] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %108 = llvm.load %107 : !llvm.ptr -> f32
        %109 = llvm.fadd %102, %108 : f32
        %110 = llvm.intr.maximum(%109, %8) : (f32, f32) -> f32
        %111 = llvm.extractvalue %92[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
        %112 = llvm.mlir.constant(128 : index) : i64
        %113 = llvm.mul %95, %112 overflow<nsw, nuw> : i64
        %114 = llvm.add %113, %96 overflow<nsw, nuw> : i64
        %115 = llvm.getelementptr inbounds|nuw %111[%114] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        llvm.store %110, %115 : f32, !llvm.ptr
      }
    }
    %94 = bufferization.to_tensor %93 : memref<1x128xf32> to tensor<1x128xf32>
    return %94 : tensor<1x128xf32>
  }
  func.func @wide_linear_layer_f32(%arg0: tensor<64x256xf32>, %arg1: tensor<256x1024xf32>, %arg2: tensor<1024xf32>) -> tensor<64x1024xf32> {
    %0 = llvm.mlir.constant(256 : index) : i64
    %1 = builtin.unrealized_conversion_cast %0 : i64 to index
    %2 = llvm.mlir.constant(1024 : index) : i64
    %3 = builtin.unrealized_conversion_cast %2 : i64 to index
    %4 = llvm.mlir.constant(1 : index) : i64
    %5 = builtin.unrealized_conversion_cast %4 : i64 to index
    %6 = llvm.mlir.constant(64 : index) : i64
    %7 = builtin.unrealized_conversion_cast %6 : i64 to index
    %8 = llvm.mlir.constant(0 : index) : i64
    %9 = builtin.unrealized_conversion_cast %8 : i64 to index
    %10 = llvm.mlir.constant(0.000000e+00 : f32) : f32
    %11 = bufferization.to_buffer %arg2 : tensor<1024xf32> to memref<1024xf32, strided<[?], offset: ?>>
    %12 = builtin.unrealized_conversion_cast %11 : memref<1024xf32, strided<[?], offset: ?>> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %13 = bufferization.to_buffer %arg1 : tensor<256x1024xf32> to memref<256x1024xf32, strided<[?, ?], offset: ?>>
    %14 = builtin.unrealized_conversion_cast %13 : memref<256x1024xf32, strided<[?, ?], offset: ?>> to !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)>
    %15 = bufferization.to_buffer %arg0 : tensor<64x256xf32> to memref<64x256xf32, strided<[?, ?], offset: ?>>
    %16 = builtin.unrealized_conversion_cast %15 : memref<64x256xf32, strided<[?, ?], offset: ?>> to !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)>
    %17 = llvm.mlir.constant(64 : index) : i64
    %18 = llvm.mlir.constant(1024 : index) : i64
    %19 = llvm.mlir.constant(1 : index) : i64
    %20 = llvm.mlir.constant(65536 : index) : i64
    %21 = llvm.mlir.zero : !llvm.ptr
    %22 = llvm.getelementptr %21[%20] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %23 = llvm.ptrtoint %22 : !llvm.ptr to i64
    %24 = llvm.mlir.constant(64 : index) : i64
    %25 = llvm.add %23, %24 : i64
    %26 = llvm.call @malloc(%25) : (i64) -> !llvm.ptr
    %27 = llvm.ptrtoint %26 : !llvm.ptr to i64
    %28 = llvm.mlir.constant(1 : index) : i64
    %29 = llvm.sub %24, %28 : i64
    %30 = llvm.add %27, %29 : i64
    %31 = llvm.urem %30, %24 : i64
    %32 = llvm.sub %30, %31 : i64
    %33 = llvm.inttoptr %32 : i64 to !llvm.ptr
    %34 = llvm.mlir.poison : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)>
    %35 = llvm.insertvalue %26, %34[0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %36 = llvm.insertvalue %33, %35[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %37 = llvm.mlir.constant(0 : index) : i64
    %38 = llvm.insertvalue %37, %36[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %39 = llvm.insertvalue %17, %38[3, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %40 = llvm.insertvalue %18, %39[3, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %41 = llvm.insertvalue %18, %40[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %42 = llvm.insertvalue %19, %41[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    scf.for %arg3 = %9 to %7 step %5 {
      %97 = builtin.unrealized_conversion_cast %arg3 : index to i64
      scf.for %arg4 = %9 to %3 step %5 {
        %98 = builtin.unrealized_conversion_cast %arg4 : index to i64
        scf.for %arg5 = %9 to %1 step %5 {
          %99 = builtin.unrealized_conversion_cast %arg5 : index to i64
          %100 = llvm.extractvalue %16[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %101 = llvm.extractvalue %16[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %102 = llvm.getelementptr %100[%101] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %103 = llvm.extractvalue %16[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %104 = llvm.mul %97, %103 overflow<nsw, nuw> : i64
          %105 = llvm.extractvalue %16[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %106 = llvm.mul %99, %105 overflow<nsw, nuw> : i64
          %107 = llvm.add %104, %106 overflow<nsw, nuw> : i64
          %108 = llvm.getelementptr inbounds|nuw %102[%107] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %109 = llvm.load %108 : !llvm.ptr -> f32
          %110 = llvm.extractvalue %14[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %111 = llvm.extractvalue %14[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %112 = llvm.getelementptr %110[%111] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %113 = llvm.extractvalue %14[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %114 = llvm.mul %99, %113 overflow<nsw, nuw> : i64
          %115 = llvm.extractvalue %14[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %116 = llvm.mul %98, %115 overflow<nsw, nuw> : i64
          %117 = llvm.add %114, %116 overflow<nsw, nuw> : i64
          %118 = llvm.getelementptr inbounds|nuw %112[%117] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %119 = llvm.load %118 : !llvm.ptr -> f32
          %120 = llvm.extractvalue %42[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %121 = llvm.mlir.constant(1024 : index) : i64
          %122 = llvm.mul %97, %121 overflow<nsw, nuw> : i64
          %123 = llvm.add %122, %98 overflow<nsw, nuw> : i64
          %124 = llvm.getelementptr inbounds|nuw %120[%123] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %125 = llvm.load %124 : !llvm.ptr -> f32
          %126 = llvm.fmul %109, %119 : f32
          %127 = llvm.fadd %125, %126 : f32
          %128 = llvm.extractvalue %42[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %129 = llvm.mlir.constant(1024 : index) : i64
          %130 = llvm.mul %97, %129 overflow<nsw, nuw> : i64
          %131 = llvm.add %130, %98 overflow<nsw, nuw> : i64
          %132 = llvm.getelementptr inbounds|nuw %128[%131] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.store %127, %132 : f32, !llvm.ptr
        }
      }
    }
    %43 = llvm.mlir.constant(64 : index) : i64
    %44 = llvm.mlir.constant(1024 : index) : i64
    %45 = llvm.mlir.constant(1 : index) : i64
    %46 = llvm.mlir.constant(65536 : index) : i64
    %47 = llvm.mlir.zero : !llvm.ptr
    %48 = llvm.getelementptr %47[%46] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %49 = llvm.ptrtoint %48 : !llvm.ptr to i64
    %50 = llvm.mlir.constant(64 : index) : i64
    %51 = llvm.add %49, %50 : i64
    %52 = llvm.call @malloc(%51) : (i64) -> !llvm.ptr
    %53 = llvm.ptrtoint %52 : !llvm.ptr to i64
    %54 = llvm.mlir.constant(1 : index) : i64
    %55 = llvm.sub %50, %54 : i64
    %56 = llvm.add %53, %55 : i64
    %57 = llvm.urem %56, %50 : i64
    %58 = llvm.sub %56, %57 : i64
    %59 = llvm.inttoptr %58 : i64 to !llvm.ptr
    %60 = llvm.mlir.poison : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)>
    %61 = llvm.insertvalue %52, %60[0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %62 = llvm.insertvalue %59, %61[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %63 = llvm.mlir.constant(0 : index) : i64
    %64 = llvm.insertvalue %63, %62[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %65 = llvm.insertvalue %43, %64[3, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %66 = llvm.insertvalue %44, %65[3, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %67 = llvm.insertvalue %44, %66[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %68 = llvm.insertvalue %45, %67[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    scf.for %arg3 = %9 to %7 step %5 {
      %97 = builtin.unrealized_conversion_cast %arg3 : index to i64
      scf.for %arg4 = %9 to %3 step %5 {
        %98 = builtin.unrealized_conversion_cast %arg4 : index to i64
        %99 = llvm.extractvalue %12[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %100 = llvm.extractvalue %12[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %101 = llvm.getelementptr %99[%100] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %102 = llvm.extractvalue %12[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %103 = llvm.mul %98, %102 overflow<nsw, nuw> : i64
        %104 = llvm.getelementptr inbounds|nuw %101[%103] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %105 = llvm.load %104 : !llvm.ptr -> f32
        %106 = llvm.extractvalue %68[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
        %107 = llvm.mlir.constant(1024 : index) : i64
        %108 = llvm.mul %97, %107 overflow<nsw, nuw> : i64
        %109 = llvm.add %108, %98 overflow<nsw, nuw> : i64
        %110 = llvm.getelementptr inbounds|nuw %106[%109] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        llvm.store %105, %110 : f32, !llvm.ptr
      }
    }
    %69 = llvm.mlir.constant(64 : index) : i64
    %70 = llvm.mlir.constant(1024 : index) : i64
    %71 = llvm.mlir.constant(1 : index) : i64
    %72 = llvm.mlir.constant(65536 : index) : i64
    %73 = llvm.mlir.zero : !llvm.ptr
    %74 = llvm.getelementptr %73[%72] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %75 = llvm.ptrtoint %74 : !llvm.ptr to i64
    %76 = llvm.mlir.constant(64 : index) : i64
    %77 = llvm.add %75, %76 : i64
    %78 = llvm.call @malloc(%77) : (i64) -> !llvm.ptr
    %79 = llvm.ptrtoint %78 : !llvm.ptr to i64
    %80 = llvm.mlir.constant(1 : index) : i64
    %81 = llvm.sub %76, %80 : i64
    %82 = llvm.add %79, %81 : i64
    %83 = llvm.urem %82, %76 : i64
    %84 = llvm.sub %82, %83 : i64
    %85 = llvm.inttoptr %84 : i64 to !llvm.ptr
    %86 = llvm.mlir.poison : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)>
    %87 = llvm.insertvalue %78, %86[0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %88 = llvm.insertvalue %85, %87[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %89 = llvm.mlir.constant(0 : index) : i64
    %90 = llvm.insertvalue %89, %88[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %91 = llvm.insertvalue %69, %90[3, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %92 = llvm.insertvalue %70, %91[3, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %93 = llvm.insertvalue %70, %92[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %94 = llvm.insertvalue %71, %93[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %95 = builtin.unrealized_conversion_cast %94 : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> to memref<64x1024xf32>
    scf.for %arg3 = %9 to %7 step %5 {
      %97 = builtin.unrealized_conversion_cast %arg3 : index to i64
      scf.for %arg4 = %9 to %3 step %5 {
        %98 = builtin.unrealized_conversion_cast %arg4 : index to i64
        %99 = llvm.extractvalue %42[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
        %100 = llvm.mlir.constant(1024 : index) : i64
        %101 = llvm.mul %97, %100 overflow<nsw, nuw> : i64
        %102 = llvm.add %101, %98 overflow<nsw, nuw> : i64
        %103 = llvm.getelementptr inbounds|nuw %99[%102] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %104 = llvm.load %103 : !llvm.ptr -> f32
        %105 = llvm.extractvalue %68[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
        %106 = llvm.mlir.constant(1024 : index) : i64
        %107 = llvm.mul %97, %106 overflow<nsw, nuw> : i64
        %108 = llvm.add %107, %98 overflow<nsw, nuw> : i64
        %109 = llvm.getelementptr inbounds|nuw %105[%108] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %110 = llvm.load %109 : !llvm.ptr -> f32
        %111 = llvm.fadd %104, %110 : f32
        %112 = llvm.intr.maximum(%111, %10) : (f32, f32) -> f32
        %113 = llvm.extractvalue %94[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
        %114 = llvm.mlir.constant(1024 : index) : i64
        %115 = llvm.mul %97, %114 overflow<nsw, nuw> : i64
        %116 = llvm.add %115, %98 overflow<nsw, nuw> : i64
        %117 = llvm.getelementptr inbounds|nuw %113[%116] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        llvm.store %112, %117 : f32, !llvm.ptr
      }
    }
    %96 = bufferization.to_tensor %95 : memref<64x1024xf32> to tensor<64x1024xf32>
    return %96 : tensor<64x1024xf32>
  }
  func.func @narrow_linear_layer_f32(%arg0: tensor<128x1024xf32>, %arg1: tensor<1024x64xf32>, %arg2: tensor<64xf32>) -> tensor<128x64xf32> {
    %0 = llvm.mlir.constant(1024 : index) : i64
    %1 = builtin.unrealized_conversion_cast %0 : i64 to index
    %2 = llvm.mlir.constant(64 : index) : i64
    %3 = builtin.unrealized_conversion_cast %2 : i64 to index
    %4 = llvm.mlir.constant(1 : index) : i64
    %5 = builtin.unrealized_conversion_cast %4 : i64 to index
    %6 = llvm.mlir.constant(128 : index) : i64
    %7 = builtin.unrealized_conversion_cast %6 : i64 to index
    %8 = llvm.mlir.constant(0 : index) : i64
    %9 = builtin.unrealized_conversion_cast %8 : i64 to index
    %10 = llvm.mlir.constant(0.000000e+00 : f32) : f32
    %11 = bufferization.to_buffer %arg2 : tensor<64xf32> to memref<64xf32, strided<[?], offset: ?>>
    %12 = builtin.unrealized_conversion_cast %11 : memref<64xf32, strided<[?], offset: ?>> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %13 = bufferization.to_buffer %arg1 : tensor<1024x64xf32> to memref<1024x64xf32, strided<[?, ?], offset: ?>>
    %14 = builtin.unrealized_conversion_cast %13 : memref<1024x64xf32, strided<[?, ?], offset: ?>> to !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)>
    %15 = bufferization.to_buffer %arg0 : tensor<128x1024xf32> to memref<128x1024xf32, strided<[?, ?], offset: ?>>
    %16 = builtin.unrealized_conversion_cast %15 : memref<128x1024xf32, strided<[?, ?], offset: ?>> to !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)>
    %17 = llvm.mlir.constant(128 : index) : i64
    %18 = llvm.mlir.constant(64 : index) : i64
    %19 = llvm.mlir.constant(1 : index) : i64
    %20 = llvm.mlir.constant(8192 : index) : i64
    %21 = llvm.mlir.zero : !llvm.ptr
    %22 = llvm.getelementptr %21[%20] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %23 = llvm.ptrtoint %22 : !llvm.ptr to i64
    %24 = llvm.mlir.constant(64 : index) : i64
    %25 = llvm.add %23, %24 : i64
    %26 = llvm.call @malloc(%25) : (i64) -> !llvm.ptr
    %27 = llvm.ptrtoint %26 : !llvm.ptr to i64
    %28 = llvm.mlir.constant(1 : index) : i64
    %29 = llvm.sub %24, %28 : i64
    %30 = llvm.add %27, %29 : i64
    %31 = llvm.urem %30, %24 : i64
    %32 = llvm.sub %30, %31 : i64
    %33 = llvm.inttoptr %32 : i64 to !llvm.ptr
    %34 = llvm.mlir.poison : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)>
    %35 = llvm.insertvalue %26, %34[0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %36 = llvm.insertvalue %33, %35[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %37 = llvm.mlir.constant(0 : index) : i64
    %38 = llvm.insertvalue %37, %36[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %39 = llvm.insertvalue %17, %38[3, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %40 = llvm.insertvalue %18, %39[3, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %41 = llvm.insertvalue %18, %40[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %42 = llvm.insertvalue %19, %41[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    scf.for %arg3 = %9 to %7 step %5 {
      %97 = builtin.unrealized_conversion_cast %arg3 : index to i64
      scf.for %arg4 = %9 to %3 step %5 {
        %98 = builtin.unrealized_conversion_cast %arg4 : index to i64
        scf.for %arg5 = %9 to %1 step %5 {
          %99 = builtin.unrealized_conversion_cast %arg5 : index to i64
          %100 = llvm.extractvalue %16[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %101 = llvm.extractvalue %16[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %102 = llvm.getelementptr %100[%101] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %103 = llvm.extractvalue %16[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %104 = llvm.mul %97, %103 overflow<nsw, nuw> : i64
          %105 = llvm.extractvalue %16[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %106 = llvm.mul %99, %105 overflow<nsw, nuw> : i64
          %107 = llvm.add %104, %106 overflow<nsw, nuw> : i64
          %108 = llvm.getelementptr inbounds|nuw %102[%107] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %109 = llvm.load %108 : !llvm.ptr -> f32
          %110 = llvm.extractvalue %14[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %111 = llvm.extractvalue %14[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %112 = llvm.getelementptr %110[%111] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %113 = llvm.extractvalue %14[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %114 = llvm.mul %99, %113 overflow<nsw, nuw> : i64
          %115 = llvm.extractvalue %14[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %116 = llvm.mul %98, %115 overflow<nsw, nuw> : i64
          %117 = llvm.add %114, %116 overflow<nsw, nuw> : i64
          %118 = llvm.getelementptr inbounds|nuw %112[%117] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %119 = llvm.load %118 : !llvm.ptr -> f32
          %120 = llvm.extractvalue %42[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %121 = llvm.mlir.constant(64 : index) : i64
          %122 = llvm.mul %97, %121 overflow<nsw, nuw> : i64
          %123 = llvm.add %122, %98 overflow<nsw, nuw> : i64
          %124 = llvm.getelementptr inbounds|nuw %120[%123] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %125 = llvm.load %124 : !llvm.ptr -> f32
          %126 = llvm.fmul %109, %119 : f32
          %127 = llvm.fadd %125, %126 : f32
          %128 = llvm.extractvalue %42[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %129 = llvm.mlir.constant(64 : index) : i64
          %130 = llvm.mul %97, %129 overflow<nsw, nuw> : i64
          %131 = llvm.add %130, %98 overflow<nsw, nuw> : i64
          %132 = llvm.getelementptr inbounds|nuw %128[%131] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.store %127, %132 : f32, !llvm.ptr
        }
      }
    }
    %43 = llvm.mlir.constant(128 : index) : i64
    %44 = llvm.mlir.constant(64 : index) : i64
    %45 = llvm.mlir.constant(1 : index) : i64
    %46 = llvm.mlir.constant(8192 : index) : i64
    %47 = llvm.mlir.zero : !llvm.ptr
    %48 = llvm.getelementptr %47[%46] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %49 = llvm.ptrtoint %48 : !llvm.ptr to i64
    %50 = llvm.mlir.constant(64 : index) : i64
    %51 = llvm.add %49, %50 : i64
    %52 = llvm.call @malloc(%51) : (i64) -> !llvm.ptr
    %53 = llvm.ptrtoint %52 : !llvm.ptr to i64
    %54 = llvm.mlir.constant(1 : index) : i64
    %55 = llvm.sub %50, %54 : i64
    %56 = llvm.add %53, %55 : i64
    %57 = llvm.urem %56, %50 : i64
    %58 = llvm.sub %56, %57 : i64
    %59 = llvm.inttoptr %58 : i64 to !llvm.ptr
    %60 = llvm.mlir.poison : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)>
    %61 = llvm.insertvalue %52, %60[0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %62 = llvm.insertvalue %59, %61[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %63 = llvm.mlir.constant(0 : index) : i64
    %64 = llvm.insertvalue %63, %62[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %65 = llvm.insertvalue %43, %64[3, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %66 = llvm.insertvalue %44, %65[3, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %67 = llvm.insertvalue %44, %66[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %68 = llvm.insertvalue %45, %67[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    scf.for %arg3 = %9 to %7 step %5 {
      %97 = builtin.unrealized_conversion_cast %arg3 : index to i64
      scf.for %arg4 = %9 to %3 step %5 {
        %98 = builtin.unrealized_conversion_cast %arg4 : index to i64
        %99 = llvm.extractvalue %12[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %100 = llvm.extractvalue %12[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %101 = llvm.getelementptr %99[%100] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %102 = llvm.extractvalue %12[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %103 = llvm.mul %98, %102 overflow<nsw, nuw> : i64
        %104 = llvm.getelementptr inbounds|nuw %101[%103] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %105 = llvm.load %104 : !llvm.ptr -> f32
        %106 = llvm.extractvalue %68[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
        %107 = llvm.mlir.constant(64 : index) : i64
        %108 = llvm.mul %97, %107 overflow<nsw, nuw> : i64
        %109 = llvm.add %108, %98 overflow<nsw, nuw> : i64
        %110 = llvm.getelementptr inbounds|nuw %106[%109] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        llvm.store %105, %110 : f32, !llvm.ptr
      }
    }
    %69 = llvm.mlir.constant(128 : index) : i64
    %70 = llvm.mlir.constant(64 : index) : i64
    %71 = llvm.mlir.constant(1 : index) : i64
    %72 = llvm.mlir.constant(8192 : index) : i64
    %73 = llvm.mlir.zero : !llvm.ptr
    %74 = llvm.getelementptr %73[%72] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %75 = llvm.ptrtoint %74 : !llvm.ptr to i64
    %76 = llvm.mlir.constant(64 : index) : i64
    %77 = llvm.add %75, %76 : i64
    %78 = llvm.call @malloc(%77) : (i64) -> !llvm.ptr
    %79 = llvm.ptrtoint %78 : !llvm.ptr to i64
    %80 = llvm.mlir.constant(1 : index) : i64
    %81 = llvm.sub %76, %80 : i64
    %82 = llvm.add %79, %81 : i64
    %83 = llvm.urem %82, %76 : i64
    %84 = llvm.sub %82, %83 : i64
    %85 = llvm.inttoptr %84 : i64 to !llvm.ptr
    %86 = llvm.mlir.poison : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)>
    %87 = llvm.insertvalue %78, %86[0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %88 = llvm.insertvalue %85, %87[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %89 = llvm.mlir.constant(0 : index) : i64
    %90 = llvm.insertvalue %89, %88[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %91 = llvm.insertvalue %69, %90[3, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %92 = llvm.insertvalue %70, %91[3, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %93 = llvm.insertvalue %70, %92[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %94 = llvm.insertvalue %71, %93[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %95 = builtin.unrealized_conversion_cast %94 : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> to memref<128x64xf32>
    scf.for %arg3 = %9 to %7 step %5 {
      %97 = builtin.unrealized_conversion_cast %arg3 : index to i64
      scf.for %arg4 = %9 to %3 step %5 {
        %98 = builtin.unrealized_conversion_cast %arg4 : index to i64
        %99 = llvm.extractvalue %42[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
        %100 = llvm.mlir.constant(64 : index) : i64
        %101 = llvm.mul %97, %100 overflow<nsw, nuw> : i64
        %102 = llvm.add %101, %98 overflow<nsw, nuw> : i64
        %103 = llvm.getelementptr inbounds|nuw %99[%102] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %104 = llvm.load %103 : !llvm.ptr -> f32
        %105 = llvm.extractvalue %68[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
        %106 = llvm.mlir.constant(64 : index) : i64
        %107 = llvm.mul %97, %106 overflow<nsw, nuw> : i64
        %108 = llvm.add %107, %98 overflow<nsw, nuw> : i64
        %109 = llvm.getelementptr inbounds|nuw %105[%108] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %110 = llvm.load %109 : !llvm.ptr -> f32
        %111 = llvm.fadd %104, %110 : f32
        %112 = llvm.intr.maximum(%111, %10) : (f32, f32) -> f32
        %113 = llvm.extractvalue %94[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
        %114 = llvm.mlir.constant(64 : index) : i64
        %115 = llvm.mul %97, %114 overflow<nsw, nuw> : i64
        %116 = llvm.add %115, %98 overflow<nsw, nuw> : i64
        %117 = llvm.getelementptr inbounds|nuw %113[%116] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        llvm.store %112, %117 : f32, !llvm.ptr
      }
    }
    %96 = bufferization.to_tensor %95 : memref<128x64xf32> to tensor<128x64xf32>
    return %96 : tensor<128x64xf32>
  }
  func.func @multi_layer_network(%arg0: tensor<32x128xf32>, %arg1: tensor<128x256xf32>, %arg2: tensor<256xf32>, %arg3: tensor<256x128xf32>, %arg4: tensor<128xf32>, %arg5: tensor<128x10xf32>, %arg6: tensor<10xf32>) -> tensor<32x10xf32> {
    %0 = llvm.mlir.constant(10 : index) : i64
    %1 = builtin.unrealized_conversion_cast %0 : i64 to index
    %2 = llvm.mlir.constant(128 : index) : i64
    %3 = builtin.unrealized_conversion_cast %2 : i64 to index
    %4 = llvm.mlir.constant(256 : index) : i64
    %5 = builtin.unrealized_conversion_cast %4 : i64 to index
    %6 = llvm.mlir.constant(1 : index) : i64
    %7 = builtin.unrealized_conversion_cast %6 : i64 to index
    %8 = llvm.mlir.constant(32 : index) : i64
    %9 = builtin.unrealized_conversion_cast %8 : i64 to index
    %10 = llvm.mlir.constant(0 : index) : i64
    %11 = builtin.unrealized_conversion_cast %10 : i64 to index
    %12 = llvm.mlir.constant(0.000000e+00 : f32) : f32
    %13 = bufferization.to_buffer %arg6 : tensor<10xf32> to memref<10xf32, strided<[?], offset: ?>>
    %14 = builtin.unrealized_conversion_cast %13 : memref<10xf32, strided<[?], offset: ?>> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %15 = bufferization.to_buffer %arg5 : tensor<128x10xf32> to memref<128x10xf32, strided<[?, ?], offset: ?>>
    %16 = builtin.unrealized_conversion_cast %15 : memref<128x10xf32, strided<[?, ?], offset: ?>> to !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)>
    %17 = bufferization.to_buffer %arg4 : tensor<128xf32> to memref<128xf32, strided<[?], offset: ?>>
    %18 = builtin.unrealized_conversion_cast %17 : memref<128xf32, strided<[?], offset: ?>> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %19 = bufferization.to_buffer %arg3 : tensor<256x128xf32> to memref<256x128xf32, strided<[?, ?], offset: ?>>
    %20 = builtin.unrealized_conversion_cast %19 : memref<256x128xf32, strided<[?, ?], offset: ?>> to !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)>
    %21 = bufferization.to_buffer %arg2 : tensor<256xf32> to memref<256xf32, strided<[?], offset: ?>>
    %22 = builtin.unrealized_conversion_cast %21 : memref<256xf32, strided<[?], offset: ?>> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %23 = bufferization.to_buffer %arg1 : tensor<128x256xf32> to memref<128x256xf32, strided<[?, ?], offset: ?>>
    %24 = builtin.unrealized_conversion_cast %23 : memref<128x256xf32, strided<[?, ?], offset: ?>> to !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)>
    %25 = bufferization.to_buffer %arg0 : tensor<32x128xf32> to memref<32x128xf32, strided<[?, ?], offset: ?>>
    %26 = builtin.unrealized_conversion_cast %25 : memref<32x128xf32, strided<[?, ?], offset: ?>> to !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)>
    %27 = llvm.mlir.constant(32 : index) : i64
    %28 = llvm.mlir.constant(256 : index) : i64
    %29 = llvm.mlir.constant(1 : index) : i64
    %30 = llvm.mlir.constant(8192 : index) : i64
    %31 = llvm.mlir.zero : !llvm.ptr
    %32 = llvm.getelementptr %31[%30] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %33 = llvm.ptrtoint %32 : !llvm.ptr to i64
    %34 = llvm.mlir.constant(64 : index) : i64
    %35 = llvm.add %33, %34 : i64
    %36 = llvm.call @malloc(%35) : (i64) -> !llvm.ptr
    %37 = llvm.ptrtoint %36 : !llvm.ptr to i64
    %38 = llvm.mlir.constant(1 : index) : i64
    %39 = llvm.sub %34, %38 : i64
    %40 = llvm.add %37, %39 : i64
    %41 = llvm.urem %40, %34 : i64
    %42 = llvm.sub %40, %41 : i64
    %43 = llvm.inttoptr %42 : i64 to !llvm.ptr
    %44 = llvm.mlir.poison : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)>
    %45 = llvm.insertvalue %36, %44[0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %46 = llvm.insertvalue %43, %45[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %47 = llvm.mlir.constant(0 : index) : i64
    %48 = llvm.insertvalue %47, %46[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %49 = llvm.insertvalue %27, %48[3, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %50 = llvm.insertvalue %28, %49[3, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %51 = llvm.insertvalue %28, %50[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %52 = llvm.insertvalue %29, %51[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    scf.for %arg7 = %11 to %9 step %7 {
      %263 = builtin.unrealized_conversion_cast %arg7 : index to i64
      scf.for %arg8 = %11 to %5 step %7 {
        %264 = builtin.unrealized_conversion_cast %arg8 : index to i64
        scf.for %arg9 = %11 to %3 step %7 {
          %265 = builtin.unrealized_conversion_cast %arg9 : index to i64
          %266 = llvm.extractvalue %26[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %267 = llvm.extractvalue %26[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %268 = llvm.getelementptr %266[%267] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %269 = llvm.extractvalue %26[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %270 = llvm.mul %263, %269 overflow<nsw, nuw> : i64
          %271 = llvm.extractvalue %26[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %272 = llvm.mul %265, %271 overflow<nsw, nuw> : i64
          %273 = llvm.add %270, %272 overflow<nsw, nuw> : i64
          %274 = llvm.getelementptr inbounds|nuw %268[%273] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %275 = llvm.load %274 : !llvm.ptr -> f32
          %276 = llvm.extractvalue %24[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %277 = llvm.extractvalue %24[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %278 = llvm.getelementptr %276[%277] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %279 = llvm.extractvalue %24[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %280 = llvm.mul %265, %279 overflow<nsw, nuw> : i64
          %281 = llvm.extractvalue %24[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %282 = llvm.mul %264, %281 overflow<nsw, nuw> : i64
          %283 = llvm.add %280, %282 overflow<nsw, nuw> : i64
          %284 = llvm.getelementptr inbounds|nuw %278[%283] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %285 = llvm.load %284 : !llvm.ptr -> f32
          %286 = llvm.extractvalue %52[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %287 = llvm.mlir.constant(256 : index) : i64
          %288 = llvm.mul %263, %287 overflow<nsw, nuw> : i64
          %289 = llvm.add %288, %264 overflow<nsw, nuw> : i64
          %290 = llvm.getelementptr inbounds|nuw %286[%289] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %291 = llvm.load %290 : !llvm.ptr -> f32
          %292 = llvm.fmul %275, %285 : f32
          %293 = llvm.fadd %291, %292 : f32
          %294 = llvm.extractvalue %52[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %295 = llvm.mlir.constant(256 : index) : i64
          %296 = llvm.mul %263, %295 overflow<nsw, nuw> : i64
          %297 = llvm.add %296, %264 overflow<nsw, nuw> : i64
          %298 = llvm.getelementptr inbounds|nuw %294[%297] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.store %293, %298 : f32, !llvm.ptr
        }
      }
    }
    %53 = llvm.mlir.constant(32 : index) : i64
    %54 = llvm.mlir.constant(256 : index) : i64
    %55 = llvm.mlir.constant(1 : index) : i64
    %56 = llvm.mlir.constant(8192 : index) : i64
    %57 = llvm.mlir.zero : !llvm.ptr
    %58 = llvm.getelementptr %57[%56] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %59 = llvm.ptrtoint %58 : !llvm.ptr to i64
    %60 = llvm.mlir.constant(64 : index) : i64
    %61 = llvm.add %59, %60 : i64
    %62 = llvm.call @malloc(%61) : (i64) -> !llvm.ptr
    %63 = llvm.ptrtoint %62 : !llvm.ptr to i64
    %64 = llvm.mlir.constant(1 : index) : i64
    %65 = llvm.sub %60, %64 : i64
    %66 = llvm.add %63, %65 : i64
    %67 = llvm.urem %66, %60 : i64
    %68 = llvm.sub %66, %67 : i64
    %69 = llvm.inttoptr %68 : i64 to !llvm.ptr
    %70 = llvm.mlir.poison : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)>
    %71 = llvm.insertvalue %62, %70[0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %72 = llvm.insertvalue %69, %71[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %73 = llvm.mlir.constant(0 : index) : i64
    %74 = llvm.insertvalue %73, %72[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %75 = llvm.insertvalue %53, %74[3, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %76 = llvm.insertvalue %54, %75[3, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %77 = llvm.insertvalue %54, %76[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %78 = llvm.insertvalue %55, %77[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    scf.for %arg7 = %11 to %9 step %7 {
      %263 = builtin.unrealized_conversion_cast %arg7 : index to i64
      scf.for %arg8 = %11 to %5 step %7 {
        %264 = builtin.unrealized_conversion_cast %arg8 : index to i64
        %265 = llvm.extractvalue %22[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %266 = llvm.extractvalue %22[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %267 = llvm.getelementptr %265[%266] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %268 = llvm.extractvalue %22[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %269 = llvm.mul %264, %268 overflow<nsw, nuw> : i64
        %270 = llvm.getelementptr inbounds|nuw %267[%269] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %271 = llvm.load %270 : !llvm.ptr -> f32
        %272 = llvm.extractvalue %78[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
        %273 = llvm.mlir.constant(256 : index) : i64
        %274 = llvm.mul %263, %273 overflow<nsw, nuw> : i64
        %275 = llvm.add %274, %264 overflow<nsw, nuw> : i64
        %276 = llvm.getelementptr inbounds|nuw %272[%275] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        llvm.store %271, %276 : f32, !llvm.ptr
      }
    }
    %79 = llvm.mlir.constant(32 : index) : i64
    %80 = llvm.mlir.constant(256 : index) : i64
    %81 = llvm.mlir.constant(1 : index) : i64
    %82 = llvm.mlir.constant(8192 : index) : i64
    %83 = llvm.mlir.zero : !llvm.ptr
    %84 = llvm.getelementptr %83[%82] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %85 = llvm.ptrtoint %84 : !llvm.ptr to i64
    %86 = llvm.mlir.constant(64 : index) : i64
    %87 = llvm.add %85, %86 : i64
    %88 = llvm.call @malloc(%87) : (i64) -> !llvm.ptr
    %89 = llvm.ptrtoint %88 : !llvm.ptr to i64
    %90 = llvm.mlir.constant(1 : index) : i64
    %91 = llvm.sub %86, %90 : i64
    %92 = llvm.add %89, %91 : i64
    %93 = llvm.urem %92, %86 : i64
    %94 = llvm.sub %92, %93 : i64
    %95 = llvm.inttoptr %94 : i64 to !llvm.ptr
    %96 = llvm.mlir.poison : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)>
    %97 = llvm.insertvalue %88, %96[0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %98 = llvm.insertvalue %95, %97[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %99 = llvm.mlir.constant(0 : index) : i64
    %100 = llvm.insertvalue %99, %98[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %101 = llvm.insertvalue %79, %100[3, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %102 = llvm.insertvalue %80, %101[3, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %103 = llvm.insertvalue %80, %102[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %104 = llvm.insertvalue %81, %103[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    scf.for %arg7 = %11 to %9 step %7 {
      %263 = builtin.unrealized_conversion_cast %arg7 : index to i64
      scf.for %arg8 = %11 to %5 step %7 {
        %264 = builtin.unrealized_conversion_cast %arg8 : index to i64
        %265 = llvm.extractvalue %52[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
        %266 = llvm.mlir.constant(256 : index) : i64
        %267 = llvm.mul %263, %266 overflow<nsw, nuw> : i64
        %268 = llvm.add %267, %264 overflow<nsw, nuw> : i64
        %269 = llvm.getelementptr inbounds|nuw %265[%268] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %270 = llvm.load %269 : !llvm.ptr -> f32
        %271 = llvm.extractvalue %78[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
        %272 = llvm.mlir.constant(256 : index) : i64
        %273 = llvm.mul %263, %272 overflow<nsw, nuw> : i64
        %274 = llvm.add %273, %264 overflow<nsw, nuw> : i64
        %275 = llvm.getelementptr inbounds|nuw %271[%274] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %276 = llvm.load %275 : !llvm.ptr -> f32
        %277 = llvm.fadd %270, %276 : f32
        %278 = llvm.intr.maximum(%277, %12) : (f32, f32) -> f32
        %279 = llvm.extractvalue %104[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
        %280 = llvm.mlir.constant(256 : index) : i64
        %281 = llvm.mul %263, %280 overflow<nsw, nuw> : i64
        %282 = llvm.add %281, %264 overflow<nsw, nuw> : i64
        %283 = llvm.getelementptr inbounds|nuw %279[%282] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        llvm.store %278, %283 : f32, !llvm.ptr
      }
    }
    %105 = llvm.mlir.constant(32 : index) : i64
    %106 = llvm.mlir.constant(128 : index) : i64
    %107 = llvm.mlir.constant(1 : index) : i64
    %108 = llvm.mlir.constant(4096 : index) : i64
    %109 = llvm.mlir.zero : !llvm.ptr
    %110 = llvm.getelementptr %109[%108] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %111 = llvm.ptrtoint %110 : !llvm.ptr to i64
    %112 = llvm.mlir.constant(64 : index) : i64
    %113 = llvm.add %111, %112 : i64
    %114 = llvm.call @malloc(%113) : (i64) -> !llvm.ptr
    %115 = llvm.ptrtoint %114 : !llvm.ptr to i64
    %116 = llvm.mlir.constant(1 : index) : i64
    %117 = llvm.sub %112, %116 : i64
    %118 = llvm.add %115, %117 : i64
    %119 = llvm.urem %118, %112 : i64
    %120 = llvm.sub %118, %119 : i64
    %121 = llvm.inttoptr %120 : i64 to !llvm.ptr
    %122 = llvm.mlir.poison : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)>
    %123 = llvm.insertvalue %114, %122[0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %124 = llvm.insertvalue %121, %123[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %125 = llvm.mlir.constant(0 : index) : i64
    %126 = llvm.insertvalue %125, %124[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %127 = llvm.insertvalue %105, %126[3, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %128 = llvm.insertvalue %106, %127[3, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %129 = llvm.insertvalue %106, %128[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %130 = llvm.insertvalue %107, %129[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    scf.for %arg7 = %11 to %9 step %7 {
      %263 = builtin.unrealized_conversion_cast %arg7 : index to i64
      scf.for %arg8 = %11 to %3 step %7 {
        %264 = builtin.unrealized_conversion_cast %arg8 : index to i64
        scf.for %arg9 = %11 to %5 step %7 {
          %265 = builtin.unrealized_conversion_cast %arg9 : index to i64
          %266 = llvm.extractvalue %104[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %267 = llvm.mlir.constant(256 : index) : i64
          %268 = llvm.mul %263, %267 overflow<nsw, nuw> : i64
          %269 = llvm.add %268, %265 overflow<nsw, nuw> : i64
          %270 = llvm.getelementptr inbounds|nuw %266[%269] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %271 = llvm.load %270 : !llvm.ptr -> f32
          %272 = llvm.extractvalue %20[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %273 = llvm.extractvalue %20[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %274 = llvm.getelementptr %272[%273] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %275 = llvm.extractvalue %20[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %276 = llvm.mul %265, %275 overflow<nsw, nuw> : i64
          %277 = llvm.extractvalue %20[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %278 = llvm.mul %264, %277 overflow<nsw, nuw> : i64
          %279 = llvm.add %276, %278 overflow<nsw, nuw> : i64
          %280 = llvm.getelementptr inbounds|nuw %274[%279] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %281 = llvm.load %280 : !llvm.ptr -> f32
          %282 = llvm.extractvalue %130[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %283 = llvm.mlir.constant(128 : index) : i64
          %284 = llvm.mul %263, %283 overflow<nsw, nuw> : i64
          %285 = llvm.add %284, %264 overflow<nsw, nuw> : i64
          %286 = llvm.getelementptr inbounds|nuw %282[%285] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %287 = llvm.load %286 : !llvm.ptr -> f32
          %288 = llvm.fmul %271, %281 : f32
          %289 = llvm.fadd %287, %288 : f32
          %290 = llvm.extractvalue %130[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %291 = llvm.mlir.constant(128 : index) : i64
          %292 = llvm.mul %263, %291 overflow<nsw, nuw> : i64
          %293 = llvm.add %292, %264 overflow<nsw, nuw> : i64
          %294 = llvm.getelementptr inbounds|nuw %290[%293] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.store %289, %294 : f32, !llvm.ptr
        }
      }
    }
    %131 = llvm.mlir.constant(32 : index) : i64
    %132 = llvm.mlir.constant(128 : index) : i64
    %133 = llvm.mlir.constant(1 : index) : i64
    %134 = llvm.mlir.constant(4096 : index) : i64
    %135 = llvm.mlir.zero : !llvm.ptr
    %136 = llvm.getelementptr %135[%134] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %137 = llvm.ptrtoint %136 : !llvm.ptr to i64
    %138 = llvm.mlir.constant(64 : index) : i64
    %139 = llvm.add %137, %138 : i64
    %140 = llvm.call @malloc(%139) : (i64) -> !llvm.ptr
    %141 = llvm.ptrtoint %140 : !llvm.ptr to i64
    %142 = llvm.mlir.constant(1 : index) : i64
    %143 = llvm.sub %138, %142 : i64
    %144 = llvm.add %141, %143 : i64
    %145 = llvm.urem %144, %138 : i64
    %146 = llvm.sub %144, %145 : i64
    %147 = llvm.inttoptr %146 : i64 to !llvm.ptr
    %148 = llvm.mlir.poison : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)>
    %149 = llvm.insertvalue %140, %148[0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %150 = llvm.insertvalue %147, %149[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %151 = llvm.mlir.constant(0 : index) : i64
    %152 = llvm.insertvalue %151, %150[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %153 = llvm.insertvalue %131, %152[3, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %154 = llvm.insertvalue %132, %153[3, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %155 = llvm.insertvalue %132, %154[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %156 = llvm.insertvalue %133, %155[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    scf.for %arg7 = %11 to %9 step %7 {
      %263 = builtin.unrealized_conversion_cast %arg7 : index to i64
      scf.for %arg8 = %11 to %3 step %7 {
        %264 = builtin.unrealized_conversion_cast %arg8 : index to i64
        %265 = llvm.extractvalue %18[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %266 = llvm.extractvalue %18[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %267 = llvm.getelementptr %265[%266] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %268 = llvm.extractvalue %18[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %269 = llvm.mul %264, %268 overflow<nsw, nuw> : i64
        %270 = llvm.getelementptr inbounds|nuw %267[%269] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %271 = llvm.load %270 : !llvm.ptr -> f32
        %272 = llvm.extractvalue %156[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
        %273 = llvm.mlir.constant(128 : index) : i64
        %274 = llvm.mul %263, %273 overflow<nsw, nuw> : i64
        %275 = llvm.add %274, %264 overflow<nsw, nuw> : i64
        %276 = llvm.getelementptr inbounds|nuw %272[%275] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        llvm.store %271, %276 : f32, !llvm.ptr
      }
    }
    %157 = llvm.mlir.constant(32 : index) : i64
    %158 = llvm.mlir.constant(128 : index) : i64
    %159 = llvm.mlir.constant(1 : index) : i64
    %160 = llvm.mlir.constant(4096 : index) : i64
    %161 = llvm.mlir.zero : !llvm.ptr
    %162 = llvm.getelementptr %161[%160] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %163 = llvm.ptrtoint %162 : !llvm.ptr to i64
    %164 = llvm.mlir.constant(64 : index) : i64
    %165 = llvm.add %163, %164 : i64
    %166 = llvm.call @malloc(%165) : (i64) -> !llvm.ptr
    %167 = llvm.ptrtoint %166 : !llvm.ptr to i64
    %168 = llvm.mlir.constant(1 : index) : i64
    %169 = llvm.sub %164, %168 : i64
    %170 = llvm.add %167, %169 : i64
    %171 = llvm.urem %170, %164 : i64
    %172 = llvm.sub %170, %171 : i64
    %173 = llvm.inttoptr %172 : i64 to !llvm.ptr
    %174 = llvm.mlir.poison : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)>
    %175 = llvm.insertvalue %166, %174[0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %176 = llvm.insertvalue %173, %175[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %177 = llvm.mlir.constant(0 : index) : i64
    %178 = llvm.insertvalue %177, %176[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %179 = llvm.insertvalue %157, %178[3, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %180 = llvm.insertvalue %158, %179[3, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %181 = llvm.insertvalue %158, %180[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %182 = llvm.insertvalue %159, %181[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    scf.for %arg7 = %11 to %9 step %7 {
      %263 = builtin.unrealized_conversion_cast %arg7 : index to i64
      scf.for %arg8 = %11 to %3 step %7 {
        %264 = builtin.unrealized_conversion_cast %arg8 : index to i64
        %265 = llvm.extractvalue %130[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
        %266 = llvm.mlir.constant(128 : index) : i64
        %267 = llvm.mul %263, %266 overflow<nsw, nuw> : i64
        %268 = llvm.add %267, %264 overflow<nsw, nuw> : i64
        %269 = llvm.getelementptr inbounds|nuw %265[%268] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %270 = llvm.load %269 : !llvm.ptr -> f32
        %271 = llvm.extractvalue %156[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
        %272 = llvm.mlir.constant(128 : index) : i64
        %273 = llvm.mul %263, %272 overflow<nsw, nuw> : i64
        %274 = llvm.add %273, %264 overflow<nsw, nuw> : i64
        %275 = llvm.getelementptr inbounds|nuw %271[%274] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %276 = llvm.load %275 : !llvm.ptr -> f32
        %277 = llvm.fadd %270, %276 : f32
        %278 = llvm.intr.maximum(%277, %12) : (f32, f32) -> f32
        %279 = llvm.extractvalue %182[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
        %280 = llvm.mlir.constant(128 : index) : i64
        %281 = llvm.mul %263, %280 overflow<nsw, nuw> : i64
        %282 = llvm.add %281, %264 overflow<nsw, nuw> : i64
        %283 = llvm.getelementptr inbounds|nuw %279[%282] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        llvm.store %278, %283 : f32, !llvm.ptr
      }
    }
    %183 = llvm.mlir.constant(32 : index) : i64
    %184 = llvm.mlir.constant(10 : index) : i64
    %185 = llvm.mlir.constant(1 : index) : i64
    %186 = llvm.mlir.constant(320 : index) : i64
    %187 = llvm.mlir.zero : !llvm.ptr
    %188 = llvm.getelementptr %187[%186] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %189 = llvm.ptrtoint %188 : !llvm.ptr to i64
    %190 = llvm.mlir.constant(64 : index) : i64
    %191 = llvm.add %189, %190 : i64
    %192 = llvm.call @malloc(%191) : (i64) -> !llvm.ptr
    %193 = llvm.ptrtoint %192 : !llvm.ptr to i64
    %194 = llvm.mlir.constant(1 : index) : i64
    %195 = llvm.sub %190, %194 : i64
    %196 = llvm.add %193, %195 : i64
    %197 = llvm.urem %196, %190 : i64
    %198 = llvm.sub %196, %197 : i64
    %199 = llvm.inttoptr %198 : i64 to !llvm.ptr
    %200 = llvm.mlir.poison : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)>
    %201 = llvm.insertvalue %192, %200[0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %202 = llvm.insertvalue %199, %201[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %203 = llvm.mlir.constant(0 : index) : i64
    %204 = llvm.insertvalue %203, %202[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %205 = llvm.insertvalue %183, %204[3, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %206 = llvm.insertvalue %184, %205[3, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %207 = llvm.insertvalue %184, %206[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %208 = llvm.insertvalue %185, %207[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    scf.for %arg7 = %11 to %9 step %7 {
      %263 = builtin.unrealized_conversion_cast %arg7 : index to i64
      scf.for %arg8 = %11 to %1 step %7 {
        %264 = builtin.unrealized_conversion_cast %arg8 : index to i64
        scf.for %arg9 = %11 to %3 step %7 {
          %265 = builtin.unrealized_conversion_cast %arg9 : index to i64
          %266 = llvm.extractvalue %182[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %267 = llvm.mlir.constant(128 : index) : i64
          %268 = llvm.mul %263, %267 overflow<nsw, nuw> : i64
          %269 = llvm.add %268, %265 overflow<nsw, nuw> : i64
          %270 = llvm.getelementptr inbounds|nuw %266[%269] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %271 = llvm.load %270 : !llvm.ptr -> f32
          %272 = llvm.extractvalue %16[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %273 = llvm.extractvalue %16[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %274 = llvm.getelementptr %272[%273] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %275 = llvm.extractvalue %16[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %276 = llvm.mul %265, %275 overflow<nsw, nuw> : i64
          %277 = llvm.extractvalue %16[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %278 = llvm.mul %264, %277 overflow<nsw, nuw> : i64
          %279 = llvm.add %276, %278 overflow<nsw, nuw> : i64
          %280 = llvm.getelementptr inbounds|nuw %274[%279] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %281 = llvm.load %280 : !llvm.ptr -> f32
          %282 = llvm.extractvalue %208[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %283 = llvm.mlir.constant(10 : index) : i64
          %284 = llvm.mul %263, %283 overflow<nsw, nuw> : i64
          %285 = llvm.add %284, %264 overflow<nsw, nuw> : i64
          %286 = llvm.getelementptr inbounds|nuw %282[%285] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %287 = llvm.load %286 : !llvm.ptr -> f32
          %288 = llvm.fmul %271, %281 : f32
          %289 = llvm.fadd %287, %288 : f32
          %290 = llvm.extractvalue %208[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %291 = llvm.mlir.constant(10 : index) : i64
          %292 = llvm.mul %263, %291 overflow<nsw, nuw> : i64
          %293 = llvm.add %292, %264 overflow<nsw, nuw> : i64
          %294 = llvm.getelementptr inbounds|nuw %290[%293] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.store %289, %294 : f32, !llvm.ptr
        }
      }
    }
    %209 = llvm.mlir.constant(32 : index) : i64
    %210 = llvm.mlir.constant(10 : index) : i64
    %211 = llvm.mlir.constant(1 : index) : i64
    %212 = llvm.mlir.constant(320 : index) : i64
    %213 = llvm.mlir.zero : !llvm.ptr
    %214 = llvm.getelementptr %213[%212] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %215 = llvm.ptrtoint %214 : !llvm.ptr to i64
    %216 = llvm.mlir.constant(64 : index) : i64
    %217 = llvm.add %215, %216 : i64
    %218 = llvm.call @malloc(%217) : (i64) -> !llvm.ptr
    %219 = llvm.ptrtoint %218 : !llvm.ptr to i64
    %220 = llvm.mlir.constant(1 : index) : i64
    %221 = llvm.sub %216, %220 : i64
    %222 = llvm.add %219, %221 : i64
    %223 = llvm.urem %222, %216 : i64
    %224 = llvm.sub %222, %223 : i64
    %225 = llvm.inttoptr %224 : i64 to !llvm.ptr
    %226 = llvm.mlir.poison : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)>
    %227 = llvm.insertvalue %218, %226[0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %228 = llvm.insertvalue %225, %227[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %229 = llvm.mlir.constant(0 : index) : i64
    %230 = llvm.insertvalue %229, %228[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %231 = llvm.insertvalue %209, %230[3, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %232 = llvm.insertvalue %210, %231[3, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %233 = llvm.insertvalue %210, %232[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %234 = llvm.insertvalue %211, %233[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    scf.for %arg7 = %11 to %9 step %7 {
      %263 = builtin.unrealized_conversion_cast %arg7 : index to i64
      scf.for %arg8 = %11 to %1 step %7 {
        %264 = builtin.unrealized_conversion_cast %arg8 : index to i64
        %265 = llvm.extractvalue %14[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %266 = llvm.extractvalue %14[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %267 = llvm.getelementptr %265[%266] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %268 = llvm.extractvalue %14[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %269 = llvm.mul %264, %268 overflow<nsw, nuw> : i64
        %270 = llvm.getelementptr inbounds|nuw %267[%269] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %271 = llvm.load %270 : !llvm.ptr -> f32
        %272 = llvm.extractvalue %234[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
        %273 = llvm.mlir.constant(10 : index) : i64
        %274 = llvm.mul %263, %273 overflow<nsw, nuw> : i64
        %275 = llvm.add %274, %264 overflow<nsw, nuw> : i64
        %276 = llvm.getelementptr inbounds|nuw %272[%275] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        llvm.store %271, %276 : f32, !llvm.ptr
      }
    }
    %235 = llvm.mlir.constant(32 : index) : i64
    %236 = llvm.mlir.constant(10 : index) : i64
    %237 = llvm.mlir.constant(1 : index) : i64
    %238 = llvm.mlir.constant(320 : index) : i64
    %239 = llvm.mlir.zero : !llvm.ptr
    %240 = llvm.getelementptr %239[%238] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %241 = llvm.ptrtoint %240 : !llvm.ptr to i64
    %242 = llvm.mlir.constant(64 : index) : i64
    %243 = llvm.add %241, %242 : i64
    %244 = llvm.call @malloc(%243) : (i64) -> !llvm.ptr
    %245 = llvm.ptrtoint %244 : !llvm.ptr to i64
    %246 = llvm.mlir.constant(1 : index) : i64
    %247 = llvm.sub %242, %246 : i64
    %248 = llvm.add %245, %247 : i64
    %249 = llvm.urem %248, %242 : i64
    %250 = llvm.sub %248, %249 : i64
    %251 = llvm.inttoptr %250 : i64 to !llvm.ptr
    %252 = llvm.mlir.poison : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)>
    %253 = llvm.insertvalue %244, %252[0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %254 = llvm.insertvalue %251, %253[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %255 = llvm.mlir.constant(0 : index) : i64
    %256 = llvm.insertvalue %255, %254[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %257 = llvm.insertvalue %235, %256[3, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %258 = llvm.insertvalue %236, %257[3, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %259 = llvm.insertvalue %236, %258[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %260 = llvm.insertvalue %237, %259[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %261 = builtin.unrealized_conversion_cast %260 : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> to memref<32x10xf32>
    scf.for %arg7 = %11 to %9 step %7 {
      %263 = builtin.unrealized_conversion_cast %arg7 : index to i64
      scf.for %arg8 = %11 to %1 step %7 {
        %264 = builtin.unrealized_conversion_cast %arg8 : index to i64
        %265 = llvm.extractvalue %208[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
        %266 = llvm.mlir.constant(10 : index) : i64
        %267 = llvm.mul %263, %266 overflow<nsw, nuw> : i64
        %268 = llvm.add %267, %264 overflow<nsw, nuw> : i64
        %269 = llvm.getelementptr inbounds|nuw %265[%268] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %270 = llvm.load %269 : !llvm.ptr -> f32
        %271 = llvm.extractvalue %234[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
        %272 = llvm.mlir.constant(10 : index) : i64
        %273 = llvm.mul %263, %272 overflow<nsw, nuw> : i64
        %274 = llvm.add %273, %264 overflow<nsw, nuw> : i64
        %275 = llvm.getelementptr inbounds|nuw %271[%274] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %276 = llvm.load %275 : !llvm.ptr -> f32
        %277 = llvm.fadd %270, %276 : f32
        %278 = llvm.extractvalue %260[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
        %279 = llvm.mlir.constant(10 : index) : i64
        %280 = llvm.mul %263, %279 overflow<nsw, nuw> : i64
        %281 = llvm.add %280, %264 overflow<nsw, nuw> : i64
        %282 = llvm.getelementptr inbounds|nuw %278[%281] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        llvm.store %277, %282 : f32, !llvm.ptr
      }
    }
    %262 = bufferization.to_tensor %261 : memref<32x10xf32> to tensor<32x10xf32>
    return %262 : tensor<32x10xf32>
  }
  func.func @irregular_linear_layer(%arg0: tensor<17x97xf32>, %arg1: tensor<97x53xf32>, %arg2: tensor<53xf32>) -> tensor<17x53xf32> {
    %0 = llvm.mlir.constant(97 : index) : i64
    %1 = builtin.unrealized_conversion_cast %0 : i64 to index
    %2 = llvm.mlir.constant(53 : index) : i64
    %3 = builtin.unrealized_conversion_cast %2 : i64 to index
    %4 = llvm.mlir.constant(1 : index) : i64
    %5 = builtin.unrealized_conversion_cast %4 : i64 to index
    %6 = llvm.mlir.constant(17 : index) : i64
    %7 = builtin.unrealized_conversion_cast %6 : i64 to index
    %8 = llvm.mlir.constant(0 : index) : i64
    %9 = builtin.unrealized_conversion_cast %8 : i64 to index
    %10 = llvm.mlir.constant(0.000000e+00 : f32) : f32
    %11 = bufferization.to_buffer %arg2 : tensor<53xf32> to memref<53xf32, strided<[?], offset: ?>>
    %12 = builtin.unrealized_conversion_cast %11 : memref<53xf32, strided<[?], offset: ?>> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %13 = bufferization.to_buffer %arg1 : tensor<97x53xf32> to memref<97x53xf32, strided<[?, ?], offset: ?>>
    %14 = builtin.unrealized_conversion_cast %13 : memref<97x53xf32, strided<[?, ?], offset: ?>> to !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)>
    %15 = bufferization.to_buffer %arg0 : tensor<17x97xf32> to memref<17x97xf32, strided<[?, ?], offset: ?>>
    %16 = builtin.unrealized_conversion_cast %15 : memref<17x97xf32, strided<[?, ?], offset: ?>> to !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)>
    %17 = llvm.mlir.constant(17 : index) : i64
    %18 = llvm.mlir.constant(53 : index) : i64
    %19 = llvm.mlir.constant(1 : index) : i64
    %20 = llvm.mlir.constant(901 : index) : i64
    %21 = llvm.mlir.zero : !llvm.ptr
    %22 = llvm.getelementptr %21[%20] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %23 = llvm.ptrtoint %22 : !llvm.ptr to i64
    %24 = llvm.mlir.constant(64 : index) : i64
    %25 = llvm.add %23, %24 : i64
    %26 = llvm.call @malloc(%25) : (i64) -> !llvm.ptr
    %27 = llvm.ptrtoint %26 : !llvm.ptr to i64
    %28 = llvm.mlir.constant(1 : index) : i64
    %29 = llvm.sub %24, %28 : i64
    %30 = llvm.add %27, %29 : i64
    %31 = llvm.urem %30, %24 : i64
    %32 = llvm.sub %30, %31 : i64
    %33 = llvm.inttoptr %32 : i64 to !llvm.ptr
    %34 = llvm.mlir.poison : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)>
    %35 = llvm.insertvalue %26, %34[0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %36 = llvm.insertvalue %33, %35[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %37 = llvm.mlir.constant(0 : index) : i64
    %38 = llvm.insertvalue %37, %36[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %39 = llvm.insertvalue %17, %38[3, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %40 = llvm.insertvalue %18, %39[3, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %41 = llvm.insertvalue %18, %40[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %42 = llvm.insertvalue %19, %41[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    scf.for %arg3 = %9 to %7 step %5 {
      %97 = builtin.unrealized_conversion_cast %arg3 : index to i64
      scf.for %arg4 = %9 to %3 step %5 {
        %98 = builtin.unrealized_conversion_cast %arg4 : index to i64
        scf.for %arg5 = %9 to %1 step %5 {
          %99 = builtin.unrealized_conversion_cast %arg5 : index to i64
          %100 = llvm.extractvalue %16[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %101 = llvm.extractvalue %16[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %102 = llvm.getelementptr %100[%101] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %103 = llvm.extractvalue %16[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %104 = llvm.mul %97, %103 overflow<nsw, nuw> : i64
          %105 = llvm.extractvalue %16[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %106 = llvm.mul %99, %105 overflow<nsw, nuw> : i64
          %107 = llvm.add %104, %106 overflow<nsw, nuw> : i64
          %108 = llvm.getelementptr inbounds|nuw %102[%107] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %109 = llvm.load %108 : !llvm.ptr -> f32
          %110 = llvm.extractvalue %14[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %111 = llvm.extractvalue %14[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %112 = llvm.getelementptr %110[%111] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %113 = llvm.extractvalue %14[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %114 = llvm.mul %99, %113 overflow<nsw, nuw> : i64
          %115 = llvm.extractvalue %14[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %116 = llvm.mul %98, %115 overflow<nsw, nuw> : i64
          %117 = llvm.add %114, %116 overflow<nsw, nuw> : i64
          %118 = llvm.getelementptr inbounds|nuw %112[%117] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %119 = llvm.load %118 : !llvm.ptr -> f32
          %120 = llvm.extractvalue %42[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %121 = llvm.mlir.constant(53 : index) : i64
          %122 = llvm.mul %97, %121 overflow<nsw, nuw> : i64
          %123 = llvm.add %122, %98 overflow<nsw, nuw> : i64
          %124 = llvm.getelementptr inbounds|nuw %120[%123] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %125 = llvm.load %124 : !llvm.ptr -> f32
          %126 = llvm.fmul %109, %119 : f32
          %127 = llvm.fadd %125, %126 : f32
          %128 = llvm.extractvalue %42[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %129 = llvm.mlir.constant(53 : index) : i64
          %130 = llvm.mul %97, %129 overflow<nsw, nuw> : i64
          %131 = llvm.add %130, %98 overflow<nsw, nuw> : i64
          %132 = llvm.getelementptr inbounds|nuw %128[%131] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.store %127, %132 : f32, !llvm.ptr
        }
      }
    }
    %43 = llvm.mlir.constant(17 : index) : i64
    %44 = llvm.mlir.constant(53 : index) : i64
    %45 = llvm.mlir.constant(1 : index) : i64
    %46 = llvm.mlir.constant(901 : index) : i64
    %47 = llvm.mlir.zero : !llvm.ptr
    %48 = llvm.getelementptr %47[%46] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %49 = llvm.ptrtoint %48 : !llvm.ptr to i64
    %50 = llvm.mlir.constant(64 : index) : i64
    %51 = llvm.add %49, %50 : i64
    %52 = llvm.call @malloc(%51) : (i64) -> !llvm.ptr
    %53 = llvm.ptrtoint %52 : !llvm.ptr to i64
    %54 = llvm.mlir.constant(1 : index) : i64
    %55 = llvm.sub %50, %54 : i64
    %56 = llvm.add %53, %55 : i64
    %57 = llvm.urem %56, %50 : i64
    %58 = llvm.sub %56, %57 : i64
    %59 = llvm.inttoptr %58 : i64 to !llvm.ptr
    %60 = llvm.mlir.poison : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)>
    %61 = llvm.insertvalue %52, %60[0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %62 = llvm.insertvalue %59, %61[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %63 = llvm.mlir.constant(0 : index) : i64
    %64 = llvm.insertvalue %63, %62[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %65 = llvm.insertvalue %43, %64[3, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %66 = llvm.insertvalue %44, %65[3, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %67 = llvm.insertvalue %44, %66[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %68 = llvm.insertvalue %45, %67[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    scf.for %arg3 = %9 to %7 step %5 {
      %97 = builtin.unrealized_conversion_cast %arg3 : index to i64
      scf.for %arg4 = %9 to %3 step %5 {
        %98 = builtin.unrealized_conversion_cast %arg4 : index to i64
        %99 = llvm.extractvalue %12[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %100 = llvm.extractvalue %12[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %101 = llvm.getelementptr %99[%100] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %102 = llvm.extractvalue %12[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %103 = llvm.mul %98, %102 overflow<nsw, nuw> : i64
        %104 = llvm.getelementptr inbounds|nuw %101[%103] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %105 = llvm.load %104 : !llvm.ptr -> f32
        %106 = llvm.extractvalue %68[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
        %107 = llvm.mlir.constant(53 : index) : i64
        %108 = llvm.mul %97, %107 overflow<nsw, nuw> : i64
        %109 = llvm.add %108, %98 overflow<nsw, nuw> : i64
        %110 = llvm.getelementptr inbounds|nuw %106[%109] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        llvm.store %105, %110 : f32, !llvm.ptr
      }
    }
    %69 = llvm.mlir.constant(17 : index) : i64
    %70 = llvm.mlir.constant(53 : index) : i64
    %71 = llvm.mlir.constant(1 : index) : i64
    %72 = llvm.mlir.constant(901 : index) : i64
    %73 = llvm.mlir.zero : !llvm.ptr
    %74 = llvm.getelementptr %73[%72] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %75 = llvm.ptrtoint %74 : !llvm.ptr to i64
    %76 = llvm.mlir.constant(64 : index) : i64
    %77 = llvm.add %75, %76 : i64
    %78 = llvm.call @malloc(%77) : (i64) -> !llvm.ptr
    %79 = llvm.ptrtoint %78 : !llvm.ptr to i64
    %80 = llvm.mlir.constant(1 : index) : i64
    %81 = llvm.sub %76, %80 : i64
    %82 = llvm.add %79, %81 : i64
    %83 = llvm.urem %82, %76 : i64
    %84 = llvm.sub %82, %83 : i64
    %85 = llvm.inttoptr %84 : i64 to !llvm.ptr
    %86 = llvm.mlir.poison : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)>
    %87 = llvm.insertvalue %78, %86[0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %88 = llvm.insertvalue %85, %87[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %89 = llvm.mlir.constant(0 : index) : i64
    %90 = llvm.insertvalue %89, %88[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %91 = llvm.insertvalue %69, %90[3, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %92 = llvm.insertvalue %70, %91[3, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %93 = llvm.insertvalue %70, %92[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %94 = llvm.insertvalue %71, %93[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %95 = builtin.unrealized_conversion_cast %94 : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> to memref<17x53xf32>
    scf.for %arg3 = %9 to %7 step %5 {
      %97 = builtin.unrealized_conversion_cast %arg3 : index to i64
      scf.for %arg4 = %9 to %3 step %5 {
        %98 = builtin.unrealized_conversion_cast %arg4 : index to i64
        %99 = llvm.extractvalue %42[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
        %100 = llvm.mlir.constant(53 : index) : i64
        %101 = llvm.mul %97, %100 overflow<nsw, nuw> : i64
        %102 = llvm.add %101, %98 overflow<nsw, nuw> : i64
        %103 = llvm.getelementptr inbounds|nuw %99[%102] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %104 = llvm.load %103 : !llvm.ptr -> f32
        %105 = llvm.extractvalue %68[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
        %106 = llvm.mlir.constant(53 : index) : i64
        %107 = llvm.mul %97, %106 overflow<nsw, nuw> : i64
        %108 = llvm.add %107, %98 overflow<nsw, nuw> : i64
        %109 = llvm.getelementptr inbounds|nuw %105[%108] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %110 = llvm.load %109 : !llvm.ptr -> f32
        %111 = llvm.fadd %104, %110 : f32
        %112 = llvm.intr.maximum(%111, %10) : (f32, f32) -> f32
        %113 = llvm.extractvalue %94[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
        %114 = llvm.mlir.constant(53 : index) : i64
        %115 = llvm.mul %97, %114 overflow<nsw, nuw> : i64
        %116 = llvm.add %115, %98 overflow<nsw, nuw> : i64
        %117 = llvm.getelementptr inbounds|nuw %113[%116] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        llvm.store %112, %117 : f32, !llvm.ptr
      }
    }
    %96 = bufferization.to_tensor %95 : memref<17x53xf32> to tensor<17x53xf32>
    return %96 : tensor<17x53xf32>
  }
  func.func @linear_with_sigmoid(%arg0: tensor<32x128xf32>, %arg1: tensor<128x64xf32>, %arg2: tensor<64xf32>) -> tensor<32x64xf32> {
    %0 = llvm.mlir.constant(128 : index) : i64
    %1 = builtin.unrealized_conversion_cast %0 : i64 to index
    %2 = llvm.mlir.constant(64 : index) : i64
    %3 = builtin.unrealized_conversion_cast %2 : i64 to index
    %4 = llvm.mlir.constant(1 : index) : i64
    %5 = builtin.unrealized_conversion_cast %4 : i64 to index
    %6 = llvm.mlir.constant(32 : index) : i64
    %7 = builtin.unrealized_conversion_cast %6 : i64 to index
    %8 = llvm.mlir.constant(0 : index) : i64
    %9 = builtin.unrealized_conversion_cast %8 : i64 to index
    %10 = llvm.mlir.constant(1.000000e+00 : f32) : f32
    %11 = bufferization.to_buffer %arg2 : tensor<64xf32> to memref<64xf32, strided<[?], offset: ?>>
    %12 = builtin.unrealized_conversion_cast %11 : memref<64xf32, strided<[?], offset: ?>> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %13 = bufferization.to_buffer %arg1 : tensor<128x64xf32> to memref<128x64xf32, strided<[?, ?], offset: ?>>
    %14 = builtin.unrealized_conversion_cast %13 : memref<128x64xf32, strided<[?, ?], offset: ?>> to !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)>
    %15 = bufferization.to_buffer %arg0 : tensor<32x128xf32> to memref<32x128xf32, strided<[?, ?], offset: ?>>
    %16 = builtin.unrealized_conversion_cast %15 : memref<32x128xf32, strided<[?, ?], offset: ?>> to !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)>
    %17 = llvm.mlir.constant(32 : index) : i64
    %18 = llvm.mlir.constant(64 : index) : i64
    %19 = llvm.mlir.constant(1 : index) : i64
    %20 = llvm.mlir.constant(2048 : index) : i64
    %21 = llvm.mlir.zero : !llvm.ptr
    %22 = llvm.getelementptr %21[%20] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %23 = llvm.ptrtoint %22 : !llvm.ptr to i64
    %24 = llvm.mlir.constant(64 : index) : i64
    %25 = llvm.add %23, %24 : i64
    %26 = llvm.call @malloc(%25) : (i64) -> !llvm.ptr
    %27 = llvm.ptrtoint %26 : !llvm.ptr to i64
    %28 = llvm.mlir.constant(1 : index) : i64
    %29 = llvm.sub %24, %28 : i64
    %30 = llvm.add %27, %29 : i64
    %31 = llvm.urem %30, %24 : i64
    %32 = llvm.sub %30, %31 : i64
    %33 = llvm.inttoptr %32 : i64 to !llvm.ptr
    %34 = llvm.mlir.poison : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)>
    %35 = llvm.insertvalue %26, %34[0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %36 = llvm.insertvalue %33, %35[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %37 = llvm.mlir.constant(0 : index) : i64
    %38 = llvm.insertvalue %37, %36[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %39 = llvm.insertvalue %17, %38[3, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %40 = llvm.insertvalue %18, %39[3, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %41 = llvm.insertvalue %18, %40[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %42 = llvm.insertvalue %19, %41[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    scf.for %arg3 = %9 to %7 step %5 {
      %97 = builtin.unrealized_conversion_cast %arg3 : index to i64
      scf.for %arg4 = %9 to %3 step %5 {
        %98 = builtin.unrealized_conversion_cast %arg4 : index to i64
        scf.for %arg5 = %9 to %1 step %5 {
          %99 = builtin.unrealized_conversion_cast %arg5 : index to i64
          %100 = llvm.extractvalue %16[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %101 = llvm.extractvalue %16[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %102 = llvm.getelementptr %100[%101] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %103 = llvm.extractvalue %16[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %104 = llvm.mul %97, %103 overflow<nsw, nuw> : i64
          %105 = llvm.extractvalue %16[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %106 = llvm.mul %99, %105 overflow<nsw, nuw> : i64
          %107 = llvm.add %104, %106 overflow<nsw, nuw> : i64
          %108 = llvm.getelementptr inbounds|nuw %102[%107] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %109 = llvm.load %108 : !llvm.ptr -> f32
          %110 = llvm.extractvalue %14[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %111 = llvm.extractvalue %14[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %112 = llvm.getelementptr %110[%111] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %113 = llvm.extractvalue %14[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %114 = llvm.mul %99, %113 overflow<nsw, nuw> : i64
          %115 = llvm.extractvalue %14[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %116 = llvm.mul %98, %115 overflow<nsw, nuw> : i64
          %117 = llvm.add %114, %116 overflow<nsw, nuw> : i64
          %118 = llvm.getelementptr inbounds|nuw %112[%117] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %119 = llvm.load %118 : !llvm.ptr -> f32
          %120 = llvm.extractvalue %42[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %121 = llvm.mlir.constant(64 : index) : i64
          %122 = llvm.mul %97, %121 overflow<nsw, nuw> : i64
          %123 = llvm.add %122, %98 overflow<nsw, nuw> : i64
          %124 = llvm.getelementptr inbounds|nuw %120[%123] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %125 = llvm.load %124 : !llvm.ptr -> f32
          %126 = llvm.fmul %109, %119 : f32
          %127 = llvm.fadd %125, %126 : f32
          %128 = llvm.extractvalue %42[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %129 = llvm.mlir.constant(64 : index) : i64
          %130 = llvm.mul %97, %129 overflow<nsw, nuw> : i64
          %131 = llvm.add %130, %98 overflow<nsw, nuw> : i64
          %132 = llvm.getelementptr inbounds|nuw %128[%131] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.store %127, %132 : f32, !llvm.ptr
        }
      }
    }
    %43 = llvm.mlir.constant(32 : index) : i64
    %44 = llvm.mlir.constant(64 : index) : i64
    %45 = llvm.mlir.constant(1 : index) : i64
    %46 = llvm.mlir.constant(2048 : index) : i64
    %47 = llvm.mlir.zero : !llvm.ptr
    %48 = llvm.getelementptr %47[%46] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %49 = llvm.ptrtoint %48 : !llvm.ptr to i64
    %50 = llvm.mlir.constant(64 : index) : i64
    %51 = llvm.add %49, %50 : i64
    %52 = llvm.call @malloc(%51) : (i64) -> !llvm.ptr
    %53 = llvm.ptrtoint %52 : !llvm.ptr to i64
    %54 = llvm.mlir.constant(1 : index) : i64
    %55 = llvm.sub %50, %54 : i64
    %56 = llvm.add %53, %55 : i64
    %57 = llvm.urem %56, %50 : i64
    %58 = llvm.sub %56, %57 : i64
    %59 = llvm.inttoptr %58 : i64 to !llvm.ptr
    %60 = llvm.mlir.poison : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)>
    %61 = llvm.insertvalue %52, %60[0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %62 = llvm.insertvalue %59, %61[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %63 = llvm.mlir.constant(0 : index) : i64
    %64 = llvm.insertvalue %63, %62[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %65 = llvm.insertvalue %43, %64[3, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %66 = llvm.insertvalue %44, %65[3, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %67 = llvm.insertvalue %44, %66[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %68 = llvm.insertvalue %45, %67[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    scf.for %arg3 = %9 to %7 step %5 {
      %97 = builtin.unrealized_conversion_cast %arg3 : index to i64
      scf.for %arg4 = %9 to %3 step %5 {
        %98 = builtin.unrealized_conversion_cast %arg4 : index to i64
        %99 = llvm.extractvalue %12[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %100 = llvm.extractvalue %12[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %101 = llvm.getelementptr %99[%100] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %102 = llvm.extractvalue %12[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %103 = llvm.mul %98, %102 overflow<nsw, nuw> : i64
        %104 = llvm.getelementptr inbounds|nuw %101[%103] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %105 = llvm.load %104 : !llvm.ptr -> f32
        %106 = llvm.extractvalue %68[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
        %107 = llvm.mlir.constant(64 : index) : i64
        %108 = llvm.mul %97, %107 overflow<nsw, nuw> : i64
        %109 = llvm.add %108, %98 overflow<nsw, nuw> : i64
        %110 = llvm.getelementptr inbounds|nuw %106[%109] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        llvm.store %105, %110 : f32, !llvm.ptr
      }
    }
    %69 = llvm.mlir.constant(32 : index) : i64
    %70 = llvm.mlir.constant(64 : index) : i64
    %71 = llvm.mlir.constant(1 : index) : i64
    %72 = llvm.mlir.constant(2048 : index) : i64
    %73 = llvm.mlir.zero : !llvm.ptr
    %74 = llvm.getelementptr %73[%72] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %75 = llvm.ptrtoint %74 : !llvm.ptr to i64
    %76 = llvm.mlir.constant(64 : index) : i64
    %77 = llvm.add %75, %76 : i64
    %78 = llvm.call @malloc(%77) : (i64) -> !llvm.ptr
    %79 = llvm.ptrtoint %78 : !llvm.ptr to i64
    %80 = llvm.mlir.constant(1 : index) : i64
    %81 = llvm.sub %76, %80 : i64
    %82 = llvm.add %79, %81 : i64
    %83 = llvm.urem %82, %76 : i64
    %84 = llvm.sub %82, %83 : i64
    %85 = llvm.inttoptr %84 : i64 to !llvm.ptr
    %86 = llvm.mlir.poison : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)>
    %87 = llvm.insertvalue %78, %86[0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %88 = llvm.insertvalue %85, %87[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %89 = llvm.mlir.constant(0 : index) : i64
    %90 = llvm.insertvalue %89, %88[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %91 = llvm.insertvalue %69, %90[3, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %92 = llvm.insertvalue %70, %91[3, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %93 = llvm.insertvalue %70, %92[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %94 = llvm.insertvalue %71, %93[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %95 = builtin.unrealized_conversion_cast %94 : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> to memref<32x64xf32>
    scf.for %arg3 = %9 to %7 step %5 {
      %97 = builtin.unrealized_conversion_cast %arg3 : index to i64
      scf.for %arg4 = %9 to %3 step %5 {
        %98 = builtin.unrealized_conversion_cast %arg4 : index to i64
        %99 = llvm.extractvalue %42[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
        %100 = llvm.mlir.constant(64 : index) : i64
        %101 = llvm.mul %97, %100 overflow<nsw, nuw> : i64
        %102 = llvm.add %101, %98 overflow<nsw, nuw> : i64
        %103 = llvm.getelementptr inbounds|nuw %99[%102] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %104 = llvm.load %103 : !llvm.ptr -> f32
        %105 = llvm.extractvalue %68[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
        %106 = llvm.mlir.constant(64 : index) : i64
        %107 = llvm.mul %97, %106 overflow<nsw, nuw> : i64
        %108 = llvm.add %107, %98 overflow<nsw, nuw> : i64
        %109 = llvm.getelementptr inbounds|nuw %105[%108] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %110 = llvm.load %109 : !llvm.ptr -> f32
        %111 = llvm.fadd %104, %110 : f32
        %112 = llvm.fneg %111 : f32
        %113 = math.exp %112 : f32
        %114 = llvm.fadd %113, %10 : f32
        %115 = llvm.fdiv %10, %114 : f32
        %116 = llvm.extractvalue %94[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
        %117 = llvm.mlir.constant(64 : index) : i64
        %118 = llvm.mul %97, %117 overflow<nsw, nuw> : i64
        %119 = llvm.add %118, %98 overflow<nsw, nuw> : i64
        %120 = llvm.getelementptr inbounds|nuw %116[%119] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        llvm.store %115, %120 : f32, !llvm.ptr
      }
    }
    %96 = bufferization.to_tensor %95 : memref<32x64xf32> to tensor<32x64xf32>
    return %96 : tensor<32x64xf32>
  }
  func.func @linear_with_gelu(%arg0: tensor<32x128xf32>, %arg1: tensor<128x64xf32>, %arg2: tensor<64xf32>) -> tensor<32x64xf32> {
    %0 = llvm.mlir.constant(128 : index) : i64
    %1 = builtin.unrealized_conversion_cast %0 : i64 to index
    %2 = llvm.mlir.constant(64 : index) : i64
    %3 = builtin.unrealized_conversion_cast %2 : i64 to index
    %4 = llvm.mlir.constant(1 : index) : i64
    %5 = builtin.unrealized_conversion_cast %4 : i64 to index
    %6 = llvm.mlir.constant(32 : index) : i64
    %7 = builtin.unrealized_conversion_cast %6 : i64 to index
    %8 = llvm.mlir.constant(0 : index) : i64
    %9 = builtin.unrealized_conversion_cast %8 : i64 to index
    %10 = llvm.mlir.constant(5.000000e-01 : f32) : f32
    %11 = llvm.mlir.constant(1.000000e+00 : f32) : f32
    %12 = llvm.mlir.constant(1.41421354 : f32) : f32
    %13 = bufferization.to_buffer %arg2 : tensor<64xf32> to memref<64xf32, strided<[?], offset: ?>>
    %14 = builtin.unrealized_conversion_cast %13 : memref<64xf32, strided<[?], offset: ?>> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %15 = bufferization.to_buffer %arg1 : tensor<128x64xf32> to memref<128x64xf32, strided<[?, ?], offset: ?>>
    %16 = builtin.unrealized_conversion_cast %15 : memref<128x64xf32, strided<[?, ?], offset: ?>> to !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)>
    %17 = bufferization.to_buffer %arg0 : tensor<32x128xf32> to memref<32x128xf32, strided<[?, ?], offset: ?>>
    %18 = builtin.unrealized_conversion_cast %17 : memref<32x128xf32, strided<[?, ?], offset: ?>> to !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)>
    %19 = llvm.mlir.constant(32 : index) : i64
    %20 = llvm.mlir.constant(64 : index) : i64
    %21 = llvm.mlir.constant(1 : index) : i64
    %22 = llvm.mlir.constant(2048 : index) : i64
    %23 = llvm.mlir.zero : !llvm.ptr
    %24 = llvm.getelementptr %23[%22] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %25 = llvm.ptrtoint %24 : !llvm.ptr to i64
    %26 = llvm.mlir.constant(64 : index) : i64
    %27 = llvm.add %25, %26 : i64
    %28 = llvm.call @malloc(%27) : (i64) -> !llvm.ptr
    %29 = llvm.ptrtoint %28 : !llvm.ptr to i64
    %30 = llvm.mlir.constant(1 : index) : i64
    %31 = llvm.sub %26, %30 : i64
    %32 = llvm.add %29, %31 : i64
    %33 = llvm.urem %32, %26 : i64
    %34 = llvm.sub %32, %33 : i64
    %35 = llvm.inttoptr %34 : i64 to !llvm.ptr
    %36 = llvm.mlir.poison : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)>
    %37 = llvm.insertvalue %28, %36[0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %38 = llvm.insertvalue %35, %37[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %39 = llvm.mlir.constant(0 : index) : i64
    %40 = llvm.insertvalue %39, %38[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %41 = llvm.insertvalue %19, %40[3, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %42 = llvm.insertvalue %20, %41[3, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %43 = llvm.insertvalue %20, %42[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %44 = llvm.insertvalue %21, %43[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    scf.for %arg3 = %9 to %7 step %5 {
      %99 = builtin.unrealized_conversion_cast %arg3 : index to i64
      scf.for %arg4 = %9 to %3 step %5 {
        %100 = builtin.unrealized_conversion_cast %arg4 : index to i64
        scf.for %arg5 = %9 to %1 step %5 {
          %101 = builtin.unrealized_conversion_cast %arg5 : index to i64
          %102 = llvm.extractvalue %18[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %103 = llvm.extractvalue %18[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %104 = llvm.getelementptr %102[%103] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %105 = llvm.extractvalue %18[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %106 = llvm.mul %99, %105 overflow<nsw, nuw> : i64
          %107 = llvm.extractvalue %18[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %108 = llvm.mul %101, %107 overflow<nsw, nuw> : i64
          %109 = llvm.add %106, %108 overflow<nsw, nuw> : i64
          %110 = llvm.getelementptr inbounds|nuw %104[%109] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %111 = llvm.load %110 : !llvm.ptr -> f32
          %112 = llvm.extractvalue %16[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %113 = llvm.extractvalue %16[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %114 = llvm.getelementptr %112[%113] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %115 = llvm.extractvalue %16[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %116 = llvm.mul %101, %115 overflow<nsw, nuw> : i64
          %117 = llvm.extractvalue %16[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %118 = llvm.mul %100, %117 overflow<nsw, nuw> : i64
          %119 = llvm.add %116, %118 overflow<nsw, nuw> : i64
          %120 = llvm.getelementptr inbounds|nuw %114[%119] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %121 = llvm.load %120 : !llvm.ptr -> f32
          %122 = llvm.extractvalue %44[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %123 = llvm.mlir.constant(64 : index) : i64
          %124 = llvm.mul %99, %123 overflow<nsw, nuw> : i64
          %125 = llvm.add %124, %100 overflow<nsw, nuw> : i64
          %126 = llvm.getelementptr inbounds|nuw %122[%125] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %127 = llvm.load %126 : !llvm.ptr -> f32
          %128 = llvm.fmul %111, %121 : f32
          %129 = llvm.fadd %127, %128 : f32
          %130 = llvm.extractvalue %44[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %131 = llvm.mlir.constant(64 : index) : i64
          %132 = llvm.mul %99, %131 overflow<nsw, nuw> : i64
          %133 = llvm.add %132, %100 overflow<nsw, nuw> : i64
          %134 = llvm.getelementptr inbounds|nuw %130[%133] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.store %129, %134 : f32, !llvm.ptr
        }
      }
    }
    %45 = llvm.mlir.constant(32 : index) : i64
    %46 = llvm.mlir.constant(64 : index) : i64
    %47 = llvm.mlir.constant(1 : index) : i64
    %48 = llvm.mlir.constant(2048 : index) : i64
    %49 = llvm.mlir.zero : !llvm.ptr
    %50 = llvm.getelementptr %49[%48] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %51 = llvm.ptrtoint %50 : !llvm.ptr to i64
    %52 = llvm.mlir.constant(64 : index) : i64
    %53 = llvm.add %51, %52 : i64
    %54 = llvm.call @malloc(%53) : (i64) -> !llvm.ptr
    %55 = llvm.ptrtoint %54 : !llvm.ptr to i64
    %56 = llvm.mlir.constant(1 : index) : i64
    %57 = llvm.sub %52, %56 : i64
    %58 = llvm.add %55, %57 : i64
    %59 = llvm.urem %58, %52 : i64
    %60 = llvm.sub %58, %59 : i64
    %61 = llvm.inttoptr %60 : i64 to !llvm.ptr
    %62 = llvm.mlir.poison : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)>
    %63 = llvm.insertvalue %54, %62[0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %64 = llvm.insertvalue %61, %63[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %65 = llvm.mlir.constant(0 : index) : i64
    %66 = llvm.insertvalue %65, %64[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %67 = llvm.insertvalue %45, %66[3, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %68 = llvm.insertvalue %46, %67[3, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %69 = llvm.insertvalue %46, %68[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %70 = llvm.insertvalue %47, %69[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    scf.for %arg3 = %9 to %7 step %5 {
      %99 = builtin.unrealized_conversion_cast %arg3 : index to i64
      scf.for %arg4 = %9 to %3 step %5 {
        %100 = builtin.unrealized_conversion_cast %arg4 : index to i64
        %101 = llvm.extractvalue %14[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %102 = llvm.extractvalue %14[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %103 = llvm.getelementptr %101[%102] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %104 = llvm.extractvalue %14[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %105 = llvm.mul %100, %104 overflow<nsw, nuw> : i64
        %106 = llvm.getelementptr inbounds|nuw %103[%105] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %107 = llvm.load %106 : !llvm.ptr -> f32
        %108 = llvm.extractvalue %70[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
        %109 = llvm.mlir.constant(64 : index) : i64
        %110 = llvm.mul %99, %109 overflow<nsw, nuw> : i64
        %111 = llvm.add %110, %100 overflow<nsw, nuw> : i64
        %112 = llvm.getelementptr inbounds|nuw %108[%111] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        llvm.store %107, %112 : f32, !llvm.ptr
      }
    }
    %71 = llvm.mlir.constant(32 : index) : i64
    %72 = llvm.mlir.constant(64 : index) : i64
    %73 = llvm.mlir.constant(1 : index) : i64
    %74 = llvm.mlir.constant(2048 : index) : i64
    %75 = llvm.mlir.zero : !llvm.ptr
    %76 = llvm.getelementptr %75[%74] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %77 = llvm.ptrtoint %76 : !llvm.ptr to i64
    %78 = llvm.mlir.constant(64 : index) : i64
    %79 = llvm.add %77, %78 : i64
    %80 = llvm.call @malloc(%79) : (i64) -> !llvm.ptr
    %81 = llvm.ptrtoint %80 : !llvm.ptr to i64
    %82 = llvm.mlir.constant(1 : index) : i64
    %83 = llvm.sub %78, %82 : i64
    %84 = llvm.add %81, %83 : i64
    %85 = llvm.urem %84, %78 : i64
    %86 = llvm.sub %84, %85 : i64
    %87 = llvm.inttoptr %86 : i64 to !llvm.ptr
    %88 = llvm.mlir.poison : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)>
    %89 = llvm.insertvalue %80, %88[0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %90 = llvm.insertvalue %87, %89[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %91 = llvm.mlir.constant(0 : index) : i64
    %92 = llvm.insertvalue %91, %90[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %93 = llvm.insertvalue %71, %92[3, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %94 = llvm.insertvalue %72, %93[3, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %95 = llvm.insertvalue %72, %94[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %96 = llvm.insertvalue %73, %95[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %97 = builtin.unrealized_conversion_cast %96 : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> to memref<32x64xf32>
    scf.for %arg3 = %9 to %7 step %5 {
      %99 = builtin.unrealized_conversion_cast %arg3 : index to i64
      scf.for %arg4 = %9 to %3 step %5 {
        %100 = builtin.unrealized_conversion_cast %arg4 : index to i64
        %101 = llvm.extractvalue %44[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
        %102 = llvm.mlir.constant(64 : index) : i64
        %103 = llvm.mul %99, %102 overflow<nsw, nuw> : i64
        %104 = llvm.add %103, %100 overflow<nsw, nuw> : i64
        %105 = llvm.getelementptr inbounds|nuw %101[%104] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %106 = llvm.load %105 : !llvm.ptr -> f32
        %107 = llvm.extractvalue %70[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
        %108 = llvm.mlir.constant(64 : index) : i64
        %109 = llvm.mul %99, %108 overflow<nsw, nuw> : i64
        %110 = llvm.add %109, %100 overflow<nsw, nuw> : i64
        %111 = llvm.getelementptr inbounds|nuw %107[%110] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %112 = llvm.load %111 : !llvm.ptr -> f32
        %113 = llvm.fadd %106, %112 : f32
        %114 = llvm.fdiv %113, %12 : f32
        %115 = math.erf %114 : f32
        %116 = llvm.fadd %115, %11 : f32
        %117 = llvm.fmul %116, %10 : f32
        %118 = llvm.fmul %113, %117 : f32
        %119 = llvm.extractvalue %96[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
        %120 = llvm.mlir.constant(64 : index) : i64
        %121 = llvm.mul %99, %120 overflow<nsw, nuw> : i64
        %122 = llvm.add %121, %100 overflow<nsw, nuw> : i64
        %123 = llvm.getelementptr inbounds|nuw %119[%122] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        llvm.store %118, %123 : f32, !llvm.ptr
      }
    }
    %98 = bufferization.to_tensor %97 : memref<32x64xf32> to tensor<32x64xf32>
    return %98 : tensor<32x64xf32>
  }
  func.func @linear_with_tanh(%arg0: tensor<32x128xf32>, %arg1: tensor<128x64xf32>, %arg2: tensor<64xf32>) -> tensor<32x64xf32> {
    %0 = llvm.mlir.constant(128 : index) : i64
    %1 = builtin.unrealized_conversion_cast %0 : i64 to index
    %2 = llvm.mlir.constant(64 : index) : i64
    %3 = builtin.unrealized_conversion_cast %2 : i64 to index
    %4 = llvm.mlir.constant(1 : index) : i64
    %5 = builtin.unrealized_conversion_cast %4 : i64 to index
    %6 = llvm.mlir.constant(32 : index) : i64
    %7 = builtin.unrealized_conversion_cast %6 : i64 to index
    %8 = llvm.mlir.constant(0 : index) : i64
    %9 = builtin.unrealized_conversion_cast %8 : i64 to index
    %10 = bufferization.to_buffer %arg2 : tensor<64xf32> to memref<64xf32, strided<[?], offset: ?>>
    %11 = builtin.unrealized_conversion_cast %10 : memref<64xf32, strided<[?], offset: ?>> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %12 = bufferization.to_buffer %arg1 : tensor<128x64xf32> to memref<128x64xf32, strided<[?, ?], offset: ?>>
    %13 = builtin.unrealized_conversion_cast %12 : memref<128x64xf32, strided<[?, ?], offset: ?>> to !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)>
    %14 = bufferization.to_buffer %arg0 : tensor<32x128xf32> to memref<32x128xf32, strided<[?, ?], offset: ?>>
    %15 = builtin.unrealized_conversion_cast %14 : memref<32x128xf32, strided<[?, ?], offset: ?>> to !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)>
    %16 = llvm.mlir.constant(32 : index) : i64
    %17 = llvm.mlir.constant(64 : index) : i64
    %18 = llvm.mlir.constant(1 : index) : i64
    %19 = llvm.mlir.constant(2048 : index) : i64
    %20 = llvm.mlir.zero : !llvm.ptr
    %21 = llvm.getelementptr %20[%19] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %22 = llvm.ptrtoint %21 : !llvm.ptr to i64
    %23 = llvm.mlir.constant(64 : index) : i64
    %24 = llvm.add %22, %23 : i64
    %25 = llvm.call @malloc(%24) : (i64) -> !llvm.ptr
    %26 = llvm.ptrtoint %25 : !llvm.ptr to i64
    %27 = llvm.mlir.constant(1 : index) : i64
    %28 = llvm.sub %23, %27 : i64
    %29 = llvm.add %26, %28 : i64
    %30 = llvm.urem %29, %23 : i64
    %31 = llvm.sub %29, %30 : i64
    %32 = llvm.inttoptr %31 : i64 to !llvm.ptr
    %33 = llvm.mlir.poison : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)>
    %34 = llvm.insertvalue %25, %33[0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %35 = llvm.insertvalue %32, %34[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %36 = llvm.mlir.constant(0 : index) : i64
    %37 = llvm.insertvalue %36, %35[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %38 = llvm.insertvalue %16, %37[3, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %39 = llvm.insertvalue %17, %38[3, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %40 = llvm.insertvalue %17, %39[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %41 = llvm.insertvalue %18, %40[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    scf.for %arg3 = %9 to %7 step %5 {
      %96 = builtin.unrealized_conversion_cast %arg3 : index to i64
      scf.for %arg4 = %9 to %3 step %5 {
        %97 = builtin.unrealized_conversion_cast %arg4 : index to i64
        scf.for %arg5 = %9 to %1 step %5 {
          %98 = builtin.unrealized_conversion_cast %arg5 : index to i64
          %99 = llvm.extractvalue %15[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %100 = llvm.extractvalue %15[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %101 = llvm.getelementptr %99[%100] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %102 = llvm.extractvalue %15[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %103 = llvm.mul %96, %102 overflow<nsw, nuw> : i64
          %104 = llvm.extractvalue %15[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %105 = llvm.mul %98, %104 overflow<nsw, nuw> : i64
          %106 = llvm.add %103, %105 overflow<nsw, nuw> : i64
          %107 = llvm.getelementptr inbounds|nuw %101[%106] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %108 = llvm.load %107 : !llvm.ptr -> f32
          %109 = llvm.extractvalue %13[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %110 = llvm.extractvalue %13[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %111 = llvm.getelementptr %109[%110] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %112 = llvm.extractvalue %13[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %113 = llvm.mul %98, %112 overflow<nsw, nuw> : i64
          %114 = llvm.extractvalue %13[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %115 = llvm.mul %97, %114 overflow<nsw, nuw> : i64
          %116 = llvm.add %113, %115 overflow<nsw, nuw> : i64
          %117 = llvm.getelementptr inbounds|nuw %111[%116] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %118 = llvm.load %117 : !llvm.ptr -> f32
          %119 = llvm.extractvalue %41[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %120 = llvm.mlir.constant(64 : index) : i64
          %121 = llvm.mul %96, %120 overflow<nsw, nuw> : i64
          %122 = llvm.add %121, %97 overflow<nsw, nuw> : i64
          %123 = llvm.getelementptr inbounds|nuw %119[%122] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %124 = llvm.load %123 : !llvm.ptr -> f32
          %125 = llvm.fmul %108, %118 : f32
          %126 = llvm.fadd %124, %125 : f32
          %127 = llvm.extractvalue %41[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
          %128 = llvm.mlir.constant(64 : index) : i64
          %129 = llvm.mul %96, %128 overflow<nsw, nuw> : i64
          %130 = llvm.add %129, %97 overflow<nsw, nuw> : i64
          %131 = llvm.getelementptr inbounds|nuw %127[%130] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.store %126, %131 : f32, !llvm.ptr
        }
      }
    }
    %42 = llvm.mlir.constant(32 : index) : i64
    %43 = llvm.mlir.constant(64 : index) : i64
    %44 = llvm.mlir.constant(1 : index) : i64
    %45 = llvm.mlir.constant(2048 : index) : i64
    %46 = llvm.mlir.zero : !llvm.ptr
    %47 = llvm.getelementptr %46[%45] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %48 = llvm.ptrtoint %47 : !llvm.ptr to i64
    %49 = llvm.mlir.constant(64 : index) : i64
    %50 = llvm.add %48, %49 : i64
    %51 = llvm.call @malloc(%50) : (i64) -> !llvm.ptr
    %52 = llvm.ptrtoint %51 : !llvm.ptr to i64
    %53 = llvm.mlir.constant(1 : index) : i64
    %54 = llvm.sub %49, %53 : i64
    %55 = llvm.add %52, %54 : i64
    %56 = llvm.urem %55, %49 : i64
    %57 = llvm.sub %55, %56 : i64
    %58 = llvm.inttoptr %57 : i64 to !llvm.ptr
    %59 = llvm.mlir.poison : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)>
    %60 = llvm.insertvalue %51, %59[0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %61 = llvm.insertvalue %58, %60[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %62 = llvm.mlir.constant(0 : index) : i64
    %63 = llvm.insertvalue %62, %61[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %64 = llvm.insertvalue %42, %63[3, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %65 = llvm.insertvalue %43, %64[3, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %66 = llvm.insertvalue %43, %65[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %67 = llvm.insertvalue %44, %66[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    scf.for %arg3 = %9 to %7 step %5 {
      %96 = builtin.unrealized_conversion_cast %arg3 : index to i64
      scf.for %arg4 = %9 to %3 step %5 {
        %97 = builtin.unrealized_conversion_cast %arg4 : index to i64
        %98 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %99 = llvm.extractvalue %11[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %100 = llvm.getelementptr %98[%99] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %101 = llvm.extractvalue %11[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %102 = llvm.mul %97, %101 overflow<nsw, nuw> : i64
        %103 = llvm.getelementptr inbounds|nuw %100[%102] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %104 = llvm.load %103 : !llvm.ptr -> f32
        %105 = llvm.extractvalue %67[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
        %106 = llvm.mlir.constant(64 : index) : i64
        %107 = llvm.mul %96, %106 overflow<nsw, nuw> : i64
        %108 = llvm.add %107, %97 overflow<nsw, nuw> : i64
        %109 = llvm.getelementptr inbounds|nuw %105[%108] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        llvm.store %104, %109 : f32, !llvm.ptr
      }
    }
    %68 = llvm.mlir.constant(32 : index) : i64
    %69 = llvm.mlir.constant(64 : index) : i64
    %70 = llvm.mlir.constant(1 : index) : i64
    %71 = llvm.mlir.constant(2048 : index) : i64
    %72 = llvm.mlir.zero : !llvm.ptr
    %73 = llvm.getelementptr %72[%71] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %74 = llvm.ptrtoint %73 : !llvm.ptr to i64
    %75 = llvm.mlir.constant(64 : index) : i64
    %76 = llvm.add %74, %75 : i64
    %77 = llvm.call @malloc(%76) : (i64) -> !llvm.ptr
    %78 = llvm.ptrtoint %77 : !llvm.ptr to i64
    %79 = llvm.mlir.constant(1 : index) : i64
    %80 = llvm.sub %75, %79 : i64
    %81 = llvm.add %78, %80 : i64
    %82 = llvm.urem %81, %75 : i64
    %83 = llvm.sub %81, %82 : i64
    %84 = llvm.inttoptr %83 : i64 to !llvm.ptr
    %85 = llvm.mlir.poison : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)>
    %86 = llvm.insertvalue %77, %85[0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %87 = llvm.insertvalue %84, %86[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %88 = llvm.mlir.constant(0 : index) : i64
    %89 = llvm.insertvalue %88, %87[2] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %90 = llvm.insertvalue %68, %89[3, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %91 = llvm.insertvalue %69, %90[3, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %92 = llvm.insertvalue %69, %91[4, 0] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %93 = llvm.insertvalue %70, %92[4, 1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
    %94 = builtin.unrealized_conversion_cast %93 : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> to memref<32x64xf32>
    scf.for %arg3 = %9 to %7 step %5 {
      %96 = builtin.unrealized_conversion_cast %arg3 : index to i64
      scf.for %arg4 = %9 to %3 step %5 {
        %97 = builtin.unrealized_conversion_cast %arg4 : index to i64
        %98 = llvm.extractvalue %41[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
        %99 = llvm.mlir.constant(64 : index) : i64
        %100 = llvm.mul %96, %99 overflow<nsw, nuw> : i64
        %101 = llvm.add %100, %97 overflow<nsw, nuw> : i64
        %102 = llvm.getelementptr inbounds|nuw %98[%101] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %103 = llvm.load %102 : !llvm.ptr -> f32
        %104 = llvm.extractvalue %67[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
        %105 = llvm.mlir.constant(64 : index) : i64
        %106 = llvm.mul %96, %105 overflow<nsw, nuw> : i64
        %107 = llvm.add %106, %97 overflow<nsw, nuw> : i64
        %108 = llvm.getelementptr inbounds|nuw %104[%107] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %109 = llvm.load %108 : !llvm.ptr -> f32
        %110 = llvm.fadd %103, %109 : f32
        %111 = math.tanh %110 : f32
        %112 = llvm.extractvalue %93[1] : !llvm.struct<(ptr, ptr, i64, array<2 x i64>, array<2 x i64>)> 
        %113 = llvm.mlir.constant(64 : index) : i64
        %114 = llvm.mul %96, %113 overflow<nsw, nuw> : i64
        %115 = llvm.add %114, %97 overflow<nsw, nuw> : i64
        %116 = llvm.getelementptr inbounds|nuw %112[%115] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        llvm.store %111, %116 : f32, !llvm.ptr
      }
    }
    %95 = bufferization.to_tensor %94 : memref<32x64xf32> to tensor<32x64xf32>
    return %95 : tensor<32x64xf32>
  }
}


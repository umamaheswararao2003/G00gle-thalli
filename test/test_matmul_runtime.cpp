#include <iostream>
#include <vector>
#include <chrono>
#include <cmath>
#include <iomanip>

// External function generated by MLIR
extern "C" {
  // Function signature matches MLIR memref descriptor
  void matmul_l3_test(
    float* A_data, float* A_aligned, int64_t A_offset,
    int64_t A_size0, int64_t A_size1,
    int64_t A_stride0, int64_t A_stride1,
    float* B_data, float* B_aligned, int64_t B_offset,
    int64_t B_size0, int64_t B_size1,
    int64_t B_stride0, int64_t B_stride1,
    float* C_data, float* C_aligned, int64_t C_offset,
    int64_t C_size0, int64_t C_size1,
    int64_t C_stride0, int64_t C_stride1
  );
}

void initialize_matrix(std::vector<float>& mat, int size, float value) {
  for (int i = 0; i < size * size; i++) {
    mat[i] = value;
  }
}

bool verify_result(const std::vector<float>& C, int size, float expected) {
  const float tolerance = 0.01f;
  for (int i = 0; i < size * size; i++) {
    if (std::abs(C[i] - expected) > tolerance) {
      std::cout << "  Error at index " << i << ": expected " << expected 
                << ", got " << C[i] << std::endl;
      return false;
    }
  }
  return true;
}

double benchmark_matmul(int size, int iterations) {
  std::vector<float> A(size * size, 1.0f);
  std::vector<float> B(size * size, 1.0f);
  std::vector<float> C(size * size, 0.0f);
  
  // Warm-up run
  matmul_l3_test(
    A.data(), A.data(), 0, size, size, size, 1,
    B.data(), B.data(), 0, size, size, size, 1,
    C.data(), C.data(), 0, size, size, size, 1
  );
  
  // Benchmark
  auto start = std::chrono::high_resolution_clock::now();
  for (int i = 0; i < iterations; i++) {
    std::fill(C.begin(), C.end(), 0.0f);
    matmul_l3_test(
      A.data(), A.data(), 0, size, size, size, 1,
      B.data(), B.data(), 0, size, size, size, 1,
      C.data(), C.data(), 0, size, size, size, 1
    );
  }
  auto end = std::chrono::high_resolution_clock::now();
  
  double total_ms = std::chrono::duration<double, std::milli>(end - start).count();
  return total_ms / iterations;
}

int main(int argc, char** argv) {
  std::cout << "\n=== MLIR MatMul Runtime Test ===\n" << std::endl;
  
  const int SIZE = 1024;
  const int ITERATIONS = 5;
  
  std::cout << "Configuration:" << std::endl;
  std::cout << "  Matrix size: " << SIZE << "x" << SIZE << std::endl;
  std::cout << "  Iterations: " << ITERATIONS << std::endl;
  std::cout << "  Total FLOPs per matmul: " << (2.0 * SIZE * SIZE * SIZE) << std::endl;
  std::cout << std::endl;
  
  // Test correctness
  std::cout << "Testing correctness..." << std::endl;
  std::vector<float> A(SIZE * SIZE, 1.0f);
  std::vector<float> B(SIZE * SIZE, 1.0f);
  std::vector<float> C(SIZE * SIZE, 0.0f);
  
  matmul_l3_test(
    A.data(), A.data(), 0, SIZE, SIZE, SIZE, 1,
    B.data(), B.data(), 0, SIZE, SIZE, SIZE, 1,
    C.data(), C.data(), 0, SIZE, SIZE, SIZE, 1
  );
  
  float expected = static_cast<float>(SIZE);  // Sum of SIZE 1.0s
  bool correct = verify_result(C, SIZE, expected);
  
  if (correct) {
    std::cout << "  ✓ Correctness: PASS" << std::endl;
  } else {
    std::cout << "  ✗ Correctness: FAIL" << std::endl;
    return 1;
  }
  
  // Benchmark performance
  std::cout << "\nBenchmarking performance..." << std::endl;
  double avg_time_ms = benchmark_matmul(SIZE, ITERATIONS);
  
  double gflops = (2.0 * SIZE * SIZE * SIZE) / (avg_time_ms * 1e6);
  
  std::cout << std::fixed << std::setprecision(2);
  std::cout << "\nResults:" << std::endl;
  std::cout << "  Average time: " << avg_time_ms << " ms" << std::endl;
  std::cout << "  Performance: " << gflops << " GFLOPS" << std::endl;
  std::cout << std::endl;
  
  return 0;
}
